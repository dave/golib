package gc

import (
	"github.com/dave/golib/src/cmd/compile/internal/types"
)

// A function named init is a special case.
// It is called by the initialization before main is run.
// To make it unique within a package and also uncallable,
// the name, normally "pkg.init", is altered to "pkg.init.0".

func (psess *PackageSession) renameinit() *types.Sym {
	s := psess.lookupN("init.", psess.renameinitgen)
	psess.
		renameinitgen++
	return s
}

// anyinit reports whether there any interesting init statements.
func (psess *PackageSession) anyinit(n []*Node) bool {
	for _, ln := range n {
		switch ln.Op {
		case ODCLFUNC, ODCLCONST, ODCLTYPE, OEMPTY:
		case OAS:
			if !ln.Left.isBlank() || !psess.candiscard(ln.Right) {
				return true
			}
		default:
			return true
		}
	}

	if psess.localpkg.Name == "main" {
		return true
	}

	if psess.renameinitgen > 0 {
		return true
	}

	for _, s := range psess.types.InitSyms {
		if s.Def != nil {
			return true
		}
	}

	return false
}

// fninit hand-crafts package initialization code.
//
//      var initdone· uint8                             (1)
//      func init() {                                   (2)
//              if initdone· > 1 {                      (3)
//                      return                          (3a)
//              }
//              if initdone· == 1 {                     (4)
//                      throw()                         (4a)
//              }
//              initdone· = 1                           (5)
//              // over all matching imported symbols
//                      <pkg>.init()                    (6)
//              { <init stmts> }                        (7)
//              init.<n>() // if any                    (8)
//              initdone· = 2                           (9)
//              return                                  (10)
//      }
func (psess *PackageSession) fninit(n []*Node) {
	psess.
		lineno = psess.autogeneratedPos
	nf := psess.initfix(n)
	if !psess.anyinit(nf) {
		return
	}

	var r []*Node

	gatevar := psess.newname(psess.lookup("initdone·"))
	psess.
		addvar(gatevar, psess.types.Types[TUINT8], PEXTERN)

	initsym := psess.lookup("init")
	fn := psess.dclfunc(initsym, psess.nod(OTFUNC, nil, nil))

	a := psess.nod(OIF, nil, nil)
	a.Left = psess.nod(OGT, gatevar, psess.nodintconst(1))
	a.SetLikely(true)
	r = append(r, a)

	a.Nbody.Set1(psess.nod(ORETURN, nil, nil))

	b := psess.nod(OIF, nil, nil)
	b.Left = psess.nod(OEQ, gatevar, psess.nodintconst(1))

	b.SetLikely(true)
	r = append(r, b)

	b.Nbody.Set1(psess.nod(OCALL, psess.syslook("throwinit"), nil))

	a = psess.nod(OAS, gatevar, psess.nodintconst(1))

	r = append(r, a)

	for _, s := range psess.types.InitSyms {
		if s == initsym {
			continue
		}
		n := psess.resolve(psess.oldname(s))
		if n.Op == ONONAME {

			continue
		}
		n.checkInitFuncSignature(psess)
		a = psess.nod(OCALL, n, nil)
		r = append(r, a)
	}

	r = append(r, nf...)

	// maxInlineInitCalls is the threshold at which we switch
	// from generating calls inline to generating a static array
	// of functions and calling them in a loop.
	// See CL 41500 for more discussion.
	const maxInlineInitCalls = 500

	if psess.renameinitgen < maxInlineInitCalls {

		for i := 0; i < psess.renameinitgen; i++ {
			s := psess.lookupN("init.", i)
			n := asNode(s.Def)
			n.checkInitFuncSignature(psess)
			a = psess.nod(OCALL, n, nil)
			r = append(r, a)
		}
	} else {

		typ := psess.types.NewArray(psess.functype(nil, nil, nil), int64(psess.renameinitgen))

		fnarr := psess.staticname(typ)
		fnarr.Name.SetReadonly(true)
		for i := 0; i < psess.renameinitgen; i++ {
			s := psess.lookupN("init.", i)
			lhs := psess.nod(OINDEX, fnarr, psess.nodintconst(int64(i)))
			rhs := asNode(s.Def)
			rhs.checkInitFuncSignature(psess)
			as := psess.nod(OAS, lhs, rhs)
			as = psess.typecheck(as, Etop)
			psess.
				genAsStatic(as)
		}

		i := psess.temp(psess.types.Types[TINT])
		fnidx := psess.nod(OINDEX, fnarr, i)
		fnidx.SetBounded(true)

		zero := psess.nod(OAS, i, psess.nodintconst(0))
		cond := psess.nod(OLT, i, psess.nodintconst(int64(psess.renameinitgen)))
		incr := psess.nod(OAS, i, psess.nod(OADD, i, psess.nodintconst(1)))
		body := psess.nod(OCALL, fnidx, nil)

		loop := psess.nod(OFOR, cond, incr)
		loop.Nbody.Set1(body)
		loop.Ninit.Set1(zero)

		loop = psess.typecheck(loop, Etop)
		r = append(r, loop)
	}

	a = psess.nod(OAS, gatevar, psess.nodintconst(2))

	r = append(r, a)

	a = psess.nod(ORETURN, nil, nil)

	r = append(r, a)
	psess.
		exportsym(fn.Func.Nname)

	fn.Nbody.Set(r)
	psess.
		funcbody()
	psess.
		Curfn = fn
	fn = psess.typecheck(fn, Etop)
	psess.
		typecheckslice(r, Etop)
	psess.
		Curfn = nil
	psess.
		funccompile(fn)
}

func (n *Node) checkInitFuncSignature(psess *PackageSession) {
	if n.Type.NumRecvs(psess.types)+n.Type.NumParams(psess.types)+n.Type.NumResults(psess.types) > 0 {
		psess.
			Fatalf("init function cannot have receiver, params, or results: %v (%v)", n, n.Type)
	}
}
