// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gc

import (
	"github.com/dave/golib/src/cmd/compile/internal/types"
)

func (pstate *PackageState) renameinit() *types.Sym {
	s := pstate.lookupN("init.", pstate.renameinitgen)
	pstate.renameinitgen++
	return s
}

// anyinit reports whether there any interesting init statements.
func (pstate *PackageState) anyinit(n []*Node) bool {
	for _, ln := range n {
		switch ln.Op {
		case ODCLFUNC, ODCLCONST, ODCLTYPE, OEMPTY:
		case OAS:
			if !ln.Left.isBlank() || !pstate.candiscard(ln.Right) {
				return true
			}
		default:
			return true
		}
	}

	// is this main
	if pstate.localpkg.Name == "main" {
		return true
	}

	// is there an explicit init function
	if pstate.renameinitgen > 0 {
		return true
	}

	// are there any imported init functions
	for _, s := range pstate.types.InitSyms {
		if s.Def != nil {
			return true
		}
	}

	// then none
	return false
}

// fninit hand-crafts package initialization code.
//
//      var initdone· uint8                             (1)
//      func init() {                                   (2)
//              if initdone· > 1 {                      (3)
//                      return                          (3a)
//              }
//              if initdone· == 1 {                     (4)
//                      throw()                         (4a)
//              }
//              initdone· = 1                           (5)
//              // over all matching imported symbols
//                      <pkg>.init()                    (6)
//              { <init stmts> }                        (7)
//              init.<n>() // if any                    (8)
//              initdone· = 2                           (9)
//              return                                  (10)
//      }
func (pstate *PackageState) fninit(n []*Node) {
	pstate.lineno = pstate.autogeneratedPos
	nf := pstate.initfix(n)
	if !pstate.anyinit(nf) {
		return
	}

	var r []*Node

	// (1)
	gatevar := pstate.newname(pstate.lookup("initdone·"))
	pstate.addvar(gatevar, pstate.types.Types[TUINT8], PEXTERN)

	// (2)
	initsym := pstate.lookup("init")
	fn := pstate.dclfunc(initsym, pstate.nod(OTFUNC, nil, nil))

	// (3)
	a := pstate.nod(OIF, nil, nil)
	a.Left = pstate.nod(OGT, gatevar, pstate.nodintconst(1))
	a.SetLikely(true)
	r = append(r, a)
	// (3a)
	a.Nbody.Set1(pstate.nod(ORETURN, nil, nil))

	// (4)
	b := pstate.nod(OIF, nil, nil)
	b.Left = pstate.nod(OEQ, gatevar, pstate.nodintconst(1))
	// this actually isn't likely, but code layout is better
	// like this: no JMP needed after the call.
	b.SetLikely(true)
	r = append(r, b)
	// (4a)
	b.Nbody.Set1(pstate.nod(OCALL, pstate.syslook("throwinit"), nil))

	// (5)
	a = pstate.nod(OAS, gatevar, pstate.nodintconst(1))

	r = append(r, a)

	// (6)
	for _, s := range pstate.types.InitSyms {
		if s == initsym {
			continue
		}
		n := pstate.resolve(pstate.oldname(s))
		if n.Op == ONONAME {
			// No package-scope init function; just a
			// local variable, field name, or something.
			continue
		}
		n.checkInitFuncSignature(pstate)
		a = pstate.nod(OCALL, n, nil)
		r = append(r, a)
	}

	// (7)
	r = append(r, nf...)

	// (8)

	// maxInlineInitCalls is the threshold at which we switch
	// from generating calls inline to generating a static array
	// of functions and calling them in a loop.
	// See CL 41500 for more discussion.
	const maxInlineInitCalls = 500

	if pstate.renameinitgen < maxInlineInitCalls {
		// Not many init functions. Just call them all directly.
		for i := 0; i < pstate.renameinitgen; i++ {
			s := pstate.lookupN("init.", i)
			n := asNode(s.Def)
			n.checkInitFuncSignature(pstate)
			a = pstate.nod(OCALL, n, nil)
			r = append(r, a)
		}
	} else {
		// Lots of init functions.
		// Set up an array of functions and loop to call them.
		// This is faster to compile and similar at runtime.

		// Build type [renameinitgen]func().
		typ := pstate.types.NewArray(pstate.functype(nil, nil, nil), int64(pstate.renameinitgen))

		// Make and fill array.
		fnarr := pstate.staticname(typ)
		fnarr.Name.SetReadonly(true)
		for i := 0; i < pstate.renameinitgen; i++ {
			s := pstate.lookupN("init.", i)
			lhs := pstate.nod(OINDEX, fnarr, pstate.nodintconst(int64(i)))
			rhs := asNode(s.Def)
			rhs.checkInitFuncSignature(pstate)
			as := pstate.nod(OAS, lhs, rhs)
			as = pstate.typecheck(as, Etop)
			pstate.genAsStatic(as)
		}

		// Generate a loop that calls each function in turn.
		// for i := 0; i < renameinitgen; i++ {
		//   fnarr[i]()
		// }
		i := pstate.temp(pstate.types.Types[TINT])
		fnidx := pstate.nod(OINDEX, fnarr, i)
		fnidx.SetBounded(true)

		zero := pstate.nod(OAS, i, pstate.nodintconst(0))
		cond := pstate.nod(OLT, i, pstate.nodintconst(int64(pstate.renameinitgen)))
		incr := pstate.nod(OAS, i, pstate.nod(OADD, i, pstate.nodintconst(1)))
		body := pstate.nod(OCALL, fnidx, nil)

		loop := pstate.nod(OFOR, cond, incr)
		loop.Nbody.Set1(body)
		loop.Ninit.Set1(zero)

		loop = pstate.typecheck(loop, Etop)
		r = append(r, loop)
	}

	// (9)
	a = pstate.nod(OAS, gatevar, pstate.nodintconst(2))

	r = append(r, a)

	// (10)
	a = pstate.nod(ORETURN, nil, nil)

	r = append(r, a)
	pstate.exportsym(fn.Func.Nname)

	fn.Nbody.Set(r)
	pstate.funcbody()

	pstate.Curfn = fn
	fn = pstate.typecheck(fn, Etop)
	pstate.typecheckslice(r, Etop)
	pstate.Curfn = nil
	pstate.funccompile(fn)
}

func (n *Node) checkInitFuncSignature(pstate *PackageState) {
	if n.Type.NumRecvs(pstate.types)+n.Type.NumParams(pstate.types)+n.Type.NumResults(pstate.types) > 0 {
		pstate.Fatalf("init function cannot have receiver, params, or results: %v (%v)", n, n.Type)
	}
}
