package ssa

import "math"

import "github.com/dave/golib/src/cmd/compile/internal/types"

// in case not otherwise used
// in case not otherwise used
// in case not otherwise used
// in case not otherwise used

func (psess *PackageSession) rewriteValueAMD64(v *Value) bool {
	switch v.Op {
	case OpAMD64ADDL:
		return psess.rewriteValueAMD64_OpAMD64ADDL_0(v) || rewriteValueAMD64_OpAMD64ADDL_10(v) || psess.rewriteValueAMD64_OpAMD64ADDL_20(v)
	case OpAMD64ADDLconst:
		return rewriteValueAMD64_OpAMD64ADDLconst_0(v) || rewriteValueAMD64_OpAMD64ADDLconst_10(v)
	case OpAMD64ADDLconstmodify:
		return rewriteValueAMD64_OpAMD64ADDLconstmodify_0(v)
	case OpAMD64ADDLload:
		return rewriteValueAMD64_OpAMD64ADDLload_0(v)
	case OpAMD64ADDQ:
		return rewriteValueAMD64_OpAMD64ADDQ_0(v) || rewriteValueAMD64_OpAMD64ADDQ_10(v) || psess.rewriteValueAMD64_OpAMD64ADDQ_20(v)
	case OpAMD64ADDQconst:
		return rewriteValueAMD64_OpAMD64ADDQconst_0(v) || rewriteValueAMD64_OpAMD64ADDQconst_10(v)
	case OpAMD64ADDQconstmodify:
		return rewriteValueAMD64_OpAMD64ADDQconstmodify_0(v)
	case OpAMD64ADDQload:
		return rewriteValueAMD64_OpAMD64ADDQload_0(v)
	case OpAMD64ADDSD:
		return psess.rewriteValueAMD64_OpAMD64ADDSD_0(v)
	case OpAMD64ADDSDload:
		return rewriteValueAMD64_OpAMD64ADDSDload_0(v)
	case OpAMD64ADDSS:
		return psess.rewriteValueAMD64_OpAMD64ADDSS_0(v)
	case OpAMD64ADDSSload:
		return rewriteValueAMD64_OpAMD64ADDSSload_0(v)
	case OpAMD64ANDL:
		return psess.rewriteValueAMD64_OpAMD64ANDL_0(v)
	case OpAMD64ANDLconst:
		return rewriteValueAMD64_OpAMD64ANDLconst_0(v)
	case OpAMD64ANDLload:
		return rewriteValueAMD64_OpAMD64ANDLload_0(v)
	case OpAMD64ANDQ:
		return psess.rewriteValueAMD64_OpAMD64ANDQ_0(v)
	case OpAMD64ANDQconst:
		return rewriteValueAMD64_OpAMD64ANDQconst_0(v)
	case OpAMD64ANDQload:
		return rewriteValueAMD64_OpAMD64ANDQload_0(v)
	case OpAMD64BSFQ:
		return rewriteValueAMD64_OpAMD64BSFQ_0(v)
	case OpAMD64BTLconst:
		return rewriteValueAMD64_OpAMD64BTLconst_0(v)
	case OpAMD64BTQconst:
		return rewriteValueAMD64_OpAMD64BTQconst_0(v)
	case OpAMD64BTRLconst:
		return rewriteValueAMD64_OpAMD64BTRLconst_0(v)
	case OpAMD64BTRQconst:
		return rewriteValueAMD64_OpAMD64BTRQconst_0(v)
	case OpAMD64BTSLconst:
		return rewriteValueAMD64_OpAMD64BTSLconst_0(v)
	case OpAMD64BTSQconst:
		return rewriteValueAMD64_OpAMD64BTSQconst_0(v)
	case OpAMD64CMOVLCC:
		return rewriteValueAMD64_OpAMD64CMOVLCC_0(v)
	case OpAMD64CMOVLCS:
		return rewriteValueAMD64_OpAMD64CMOVLCS_0(v)
	case OpAMD64CMOVLEQ:
		return rewriteValueAMD64_OpAMD64CMOVLEQ_0(v)
	case OpAMD64CMOVLGE:
		return rewriteValueAMD64_OpAMD64CMOVLGE_0(v)
	case OpAMD64CMOVLGT:
		return rewriteValueAMD64_OpAMD64CMOVLGT_0(v)
	case OpAMD64CMOVLHI:
		return rewriteValueAMD64_OpAMD64CMOVLHI_0(v)
	case OpAMD64CMOVLLE:
		return rewriteValueAMD64_OpAMD64CMOVLLE_0(v)
	case OpAMD64CMOVLLS:
		return rewriteValueAMD64_OpAMD64CMOVLLS_0(v)
	case OpAMD64CMOVLLT:
		return rewriteValueAMD64_OpAMD64CMOVLLT_0(v)
	case OpAMD64CMOVLNE:
		return rewriteValueAMD64_OpAMD64CMOVLNE_0(v)
	case OpAMD64CMOVQCC:
		return rewriteValueAMD64_OpAMD64CMOVQCC_0(v)
	case OpAMD64CMOVQCS:
		return rewriteValueAMD64_OpAMD64CMOVQCS_0(v)
	case OpAMD64CMOVQEQ:
		return rewriteValueAMD64_OpAMD64CMOVQEQ_0(v)
	case OpAMD64CMOVQGE:
		return rewriteValueAMD64_OpAMD64CMOVQGE_0(v)
	case OpAMD64CMOVQGT:
		return rewriteValueAMD64_OpAMD64CMOVQGT_0(v)
	case OpAMD64CMOVQHI:
		return rewriteValueAMD64_OpAMD64CMOVQHI_0(v)
	case OpAMD64CMOVQLE:
		return rewriteValueAMD64_OpAMD64CMOVQLE_0(v)
	case OpAMD64CMOVQLS:
		return rewriteValueAMD64_OpAMD64CMOVQLS_0(v)
	case OpAMD64CMOVQLT:
		return rewriteValueAMD64_OpAMD64CMOVQLT_0(v)
	case OpAMD64CMOVQNE:
		return rewriteValueAMD64_OpAMD64CMOVQNE_0(v)
	case OpAMD64CMOVWCC:
		return rewriteValueAMD64_OpAMD64CMOVWCC_0(v)
	case OpAMD64CMOVWCS:
		return rewriteValueAMD64_OpAMD64CMOVWCS_0(v)
	case OpAMD64CMOVWEQ:
		return rewriteValueAMD64_OpAMD64CMOVWEQ_0(v)
	case OpAMD64CMOVWGE:
		return rewriteValueAMD64_OpAMD64CMOVWGE_0(v)
	case OpAMD64CMOVWGT:
		return rewriteValueAMD64_OpAMD64CMOVWGT_0(v)
	case OpAMD64CMOVWHI:
		return rewriteValueAMD64_OpAMD64CMOVWHI_0(v)
	case OpAMD64CMOVWLE:
		return rewriteValueAMD64_OpAMD64CMOVWLE_0(v)
	case OpAMD64CMOVWLS:
		return rewriteValueAMD64_OpAMD64CMOVWLS_0(v)
	case OpAMD64CMOVWLT:
		return rewriteValueAMD64_OpAMD64CMOVWLT_0(v)
	case OpAMD64CMOVWNE:
		return rewriteValueAMD64_OpAMD64CMOVWNE_0(v)
	case OpAMD64CMPB:
		return psess.rewriteValueAMD64_OpAMD64CMPB_0(v)
	case OpAMD64CMPBconst:
		return psess.rewriteValueAMD64_OpAMD64CMPBconst_0(v)
	case OpAMD64CMPBload:
		return rewriteValueAMD64_OpAMD64CMPBload_0(v)
	case OpAMD64CMPL:
		return psess.rewriteValueAMD64_OpAMD64CMPL_0(v)
	case OpAMD64CMPLconst:
		return rewriteValueAMD64_OpAMD64CMPLconst_0(v) || psess.rewriteValueAMD64_OpAMD64CMPLconst_10(v)
	case OpAMD64CMPLload:
		return rewriteValueAMD64_OpAMD64CMPLload_0(v)
	case OpAMD64CMPQ:
		return psess.rewriteValueAMD64_OpAMD64CMPQ_0(v)
	case OpAMD64CMPQconst:
		return rewriteValueAMD64_OpAMD64CMPQconst_0(v) || psess.rewriteValueAMD64_OpAMD64CMPQconst_10(v)
	case OpAMD64CMPQload:
		return rewriteValueAMD64_OpAMD64CMPQload_0(v)
	case OpAMD64CMPW:
		return psess.rewriteValueAMD64_OpAMD64CMPW_0(v)
	case OpAMD64CMPWconst:
		return psess.rewriteValueAMD64_OpAMD64CMPWconst_0(v)
	case OpAMD64CMPWload:
		return rewriteValueAMD64_OpAMD64CMPWload_0(v)
	case OpAMD64CMPXCHGLlock:
		return rewriteValueAMD64_OpAMD64CMPXCHGLlock_0(v)
	case OpAMD64CMPXCHGQlock:
		return rewriteValueAMD64_OpAMD64CMPXCHGQlock_0(v)
	case OpAMD64LEAL:
		return rewriteValueAMD64_OpAMD64LEAL_0(v)
	case OpAMD64LEAL1:
		return rewriteValueAMD64_OpAMD64LEAL1_0(v)
	case OpAMD64LEAL2:
		return rewriteValueAMD64_OpAMD64LEAL2_0(v)
	case OpAMD64LEAL4:
		return rewriteValueAMD64_OpAMD64LEAL4_0(v)
	case OpAMD64LEAL8:
		return rewriteValueAMD64_OpAMD64LEAL8_0(v)
	case OpAMD64LEAQ:
		return rewriteValueAMD64_OpAMD64LEAQ_0(v)
	case OpAMD64LEAQ1:
		return rewriteValueAMD64_OpAMD64LEAQ1_0(v)
	case OpAMD64LEAQ2:
		return rewriteValueAMD64_OpAMD64LEAQ2_0(v)
	case OpAMD64LEAQ4:
		return rewriteValueAMD64_OpAMD64LEAQ4_0(v)
	case OpAMD64LEAQ8:
		return rewriteValueAMD64_OpAMD64LEAQ8_0(v)
	case OpAMD64MOVBQSX:
		return rewriteValueAMD64_OpAMD64MOVBQSX_0(v)
	case OpAMD64MOVBQSXload:
		return rewriteValueAMD64_OpAMD64MOVBQSXload_0(v)
	case OpAMD64MOVBQZX:
		return rewriteValueAMD64_OpAMD64MOVBQZX_0(v)
	case OpAMD64MOVBload:
		return rewriteValueAMD64_OpAMD64MOVBload_0(v)
	case OpAMD64MOVBloadidx1:
		return rewriteValueAMD64_OpAMD64MOVBloadidx1_0(v)
	case OpAMD64MOVBstore:
		return rewriteValueAMD64_OpAMD64MOVBstore_0(v) || rewriteValueAMD64_OpAMD64MOVBstore_10(v) || rewriteValueAMD64_OpAMD64MOVBstore_20(v)
	case OpAMD64MOVBstoreconst:
		return rewriteValueAMD64_OpAMD64MOVBstoreconst_0(v)
	case OpAMD64MOVBstoreconstidx1:
		return rewriteValueAMD64_OpAMD64MOVBstoreconstidx1_0(v)
	case OpAMD64MOVBstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVBstoreidx1_0(v) || rewriteValueAMD64_OpAMD64MOVBstoreidx1_10(v)
	case OpAMD64MOVLQSX:
		return rewriteValueAMD64_OpAMD64MOVLQSX_0(v)
	case OpAMD64MOVLQSXload:
		return rewriteValueAMD64_OpAMD64MOVLQSXload_0(v)
	case OpAMD64MOVLQZX:
		return rewriteValueAMD64_OpAMD64MOVLQZX_0(v)
	case OpAMD64MOVLatomicload:
		return rewriteValueAMD64_OpAMD64MOVLatomicload_0(v)
	case OpAMD64MOVLf2i:
		return psess.rewriteValueAMD64_OpAMD64MOVLf2i_0(v)
	case OpAMD64MOVLi2f:
		return psess.rewriteValueAMD64_OpAMD64MOVLi2f_0(v)
	case OpAMD64MOVLload:
		return rewriteValueAMD64_OpAMD64MOVLload_0(v)
	case OpAMD64MOVLloadidx1:
		return rewriteValueAMD64_OpAMD64MOVLloadidx1_0(v)
	case OpAMD64MOVLloadidx4:
		return rewriteValueAMD64_OpAMD64MOVLloadidx4_0(v)
	case OpAMD64MOVLloadidx8:
		return rewriteValueAMD64_OpAMD64MOVLloadidx8_0(v)
	case OpAMD64MOVLstore:
		return rewriteValueAMD64_OpAMD64MOVLstore_0(v) || rewriteValueAMD64_OpAMD64MOVLstore_10(v)
	case OpAMD64MOVLstoreconst:
		return rewriteValueAMD64_OpAMD64MOVLstoreconst_0(v)
	case OpAMD64MOVLstoreconstidx1:
		return rewriteValueAMD64_OpAMD64MOVLstoreconstidx1_0(v)
	case OpAMD64MOVLstoreconstidx4:
		return rewriteValueAMD64_OpAMD64MOVLstoreconstidx4_0(v)
	case OpAMD64MOVLstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVLstoreidx1_0(v)
	case OpAMD64MOVLstoreidx4:
		return rewriteValueAMD64_OpAMD64MOVLstoreidx4_0(v)
	case OpAMD64MOVLstoreidx8:
		return rewriteValueAMD64_OpAMD64MOVLstoreidx8_0(v)
	case OpAMD64MOVOload:
		return rewriteValueAMD64_OpAMD64MOVOload_0(v)
	case OpAMD64MOVOstore:
		return rewriteValueAMD64_OpAMD64MOVOstore_0(v)
	case OpAMD64MOVQatomicload:
		return rewriteValueAMD64_OpAMD64MOVQatomicload_0(v)
	case OpAMD64MOVQf2i:
		return psess.rewriteValueAMD64_OpAMD64MOVQf2i_0(v)
	case OpAMD64MOVQi2f:
		return psess.rewriteValueAMD64_OpAMD64MOVQi2f_0(v)
	case OpAMD64MOVQload:
		return rewriteValueAMD64_OpAMD64MOVQload_0(v)
	case OpAMD64MOVQloadidx1:
		return rewriteValueAMD64_OpAMD64MOVQloadidx1_0(v)
	case OpAMD64MOVQloadidx8:
		return rewriteValueAMD64_OpAMD64MOVQloadidx8_0(v)
	case OpAMD64MOVQstore:
		return rewriteValueAMD64_OpAMD64MOVQstore_0(v)
	case OpAMD64MOVQstoreconst:
		return psess.rewriteValueAMD64_OpAMD64MOVQstoreconst_0(v)
	case OpAMD64MOVQstoreconstidx1:
		return rewriteValueAMD64_OpAMD64MOVQstoreconstidx1_0(v)
	case OpAMD64MOVQstoreconstidx8:
		return rewriteValueAMD64_OpAMD64MOVQstoreconstidx8_0(v)
	case OpAMD64MOVQstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVQstoreidx1_0(v)
	case OpAMD64MOVQstoreidx8:
		return rewriteValueAMD64_OpAMD64MOVQstoreidx8_0(v)
	case OpAMD64MOVSDload:
		return rewriteValueAMD64_OpAMD64MOVSDload_0(v)
	case OpAMD64MOVSDloadidx1:
		return rewriteValueAMD64_OpAMD64MOVSDloadidx1_0(v)
	case OpAMD64MOVSDloadidx8:
		return rewriteValueAMD64_OpAMD64MOVSDloadidx8_0(v)
	case OpAMD64MOVSDstore:
		return rewriteValueAMD64_OpAMD64MOVSDstore_0(v)
	case OpAMD64MOVSDstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVSDstoreidx1_0(v)
	case OpAMD64MOVSDstoreidx8:
		return rewriteValueAMD64_OpAMD64MOVSDstoreidx8_0(v)
	case OpAMD64MOVSSload:
		return rewriteValueAMD64_OpAMD64MOVSSload_0(v)
	case OpAMD64MOVSSloadidx1:
		return rewriteValueAMD64_OpAMD64MOVSSloadidx1_0(v)
	case OpAMD64MOVSSloadidx4:
		return rewriteValueAMD64_OpAMD64MOVSSloadidx4_0(v)
	case OpAMD64MOVSSstore:
		return rewriteValueAMD64_OpAMD64MOVSSstore_0(v)
	case OpAMD64MOVSSstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVSSstoreidx1_0(v)
	case OpAMD64MOVSSstoreidx4:
		return rewriteValueAMD64_OpAMD64MOVSSstoreidx4_0(v)
	case OpAMD64MOVWQSX:
		return rewriteValueAMD64_OpAMD64MOVWQSX_0(v)
	case OpAMD64MOVWQSXload:
		return rewriteValueAMD64_OpAMD64MOVWQSXload_0(v)
	case OpAMD64MOVWQZX:
		return rewriteValueAMD64_OpAMD64MOVWQZX_0(v)
	case OpAMD64MOVWload:
		return rewriteValueAMD64_OpAMD64MOVWload_0(v)
	case OpAMD64MOVWloadidx1:
		return rewriteValueAMD64_OpAMD64MOVWloadidx1_0(v)
	case OpAMD64MOVWloadidx2:
		return rewriteValueAMD64_OpAMD64MOVWloadidx2_0(v)
	case OpAMD64MOVWstore:
		return rewriteValueAMD64_OpAMD64MOVWstore_0(v) || rewriteValueAMD64_OpAMD64MOVWstore_10(v)
	case OpAMD64MOVWstoreconst:
		return rewriteValueAMD64_OpAMD64MOVWstoreconst_0(v)
	case OpAMD64MOVWstoreconstidx1:
		return rewriteValueAMD64_OpAMD64MOVWstoreconstidx1_0(v)
	case OpAMD64MOVWstoreconstidx2:
		return rewriteValueAMD64_OpAMD64MOVWstoreconstidx2_0(v)
	case OpAMD64MOVWstoreidx1:
		return rewriteValueAMD64_OpAMD64MOVWstoreidx1_0(v)
	case OpAMD64MOVWstoreidx2:
		return rewriteValueAMD64_OpAMD64MOVWstoreidx2_0(v)
	case OpAMD64MULL:
		return rewriteValueAMD64_OpAMD64MULL_0(v)
	case OpAMD64MULLconst:
		return rewriteValueAMD64_OpAMD64MULLconst_0(v) || rewriteValueAMD64_OpAMD64MULLconst_10(v) || rewriteValueAMD64_OpAMD64MULLconst_20(v) || rewriteValueAMD64_OpAMD64MULLconst_30(v)
	case OpAMD64MULQ:
		return rewriteValueAMD64_OpAMD64MULQ_0(v)
	case OpAMD64MULQconst:
		return rewriteValueAMD64_OpAMD64MULQconst_0(v) || rewriteValueAMD64_OpAMD64MULQconst_10(v) || rewriteValueAMD64_OpAMD64MULQconst_20(v) || rewriteValueAMD64_OpAMD64MULQconst_30(v)
	case OpAMD64MULSD:
		return psess.rewriteValueAMD64_OpAMD64MULSD_0(v)
	case OpAMD64MULSDload:
		return rewriteValueAMD64_OpAMD64MULSDload_0(v)
	case OpAMD64MULSS:
		return psess.rewriteValueAMD64_OpAMD64MULSS_0(v)
	case OpAMD64MULSSload:
		return rewriteValueAMD64_OpAMD64MULSSload_0(v)
	case OpAMD64NEGL:
		return rewriteValueAMD64_OpAMD64NEGL_0(v)
	case OpAMD64NEGQ:
		return rewriteValueAMD64_OpAMD64NEGQ_0(v)
	case OpAMD64NOTL:
		return rewriteValueAMD64_OpAMD64NOTL_0(v)
	case OpAMD64NOTQ:
		return rewriteValueAMD64_OpAMD64NOTQ_0(v)
	case OpAMD64ORL:
		return psess.rewriteValueAMD64_OpAMD64ORL_0(v) || psess.rewriteValueAMD64_OpAMD64ORL_10(v) || psess.rewriteValueAMD64_OpAMD64ORL_20(v) || psess.rewriteValueAMD64_OpAMD64ORL_30(v) || psess.rewriteValueAMD64_OpAMD64ORL_40(v) || psess.rewriteValueAMD64_OpAMD64ORL_50(v) || rewriteValueAMD64_OpAMD64ORL_60(v) || rewriteValueAMD64_OpAMD64ORL_70(v) || rewriteValueAMD64_OpAMD64ORL_80(v) || rewriteValueAMD64_OpAMD64ORL_90(v) || rewriteValueAMD64_OpAMD64ORL_100(v) || rewriteValueAMD64_OpAMD64ORL_110(v) || rewriteValueAMD64_OpAMD64ORL_120(v) || psess.rewriteValueAMD64_OpAMD64ORL_130(v)
	case OpAMD64ORLconst:
		return rewriteValueAMD64_OpAMD64ORLconst_0(v)
	case OpAMD64ORLload:
		return rewriteValueAMD64_OpAMD64ORLload_0(v)
	case OpAMD64ORQ:
		return rewriteValueAMD64_OpAMD64ORQ_0(v) || rewriteValueAMD64_OpAMD64ORQ_10(v) || rewriteValueAMD64_OpAMD64ORQ_20(v) || rewriteValueAMD64_OpAMD64ORQ_30(v) || rewriteValueAMD64_OpAMD64ORQ_40(v) || rewriteValueAMD64_OpAMD64ORQ_50(v) || rewriteValueAMD64_OpAMD64ORQ_60(v) || rewriteValueAMD64_OpAMD64ORQ_70(v) || rewriteValueAMD64_OpAMD64ORQ_80(v) || rewriteValueAMD64_OpAMD64ORQ_90(v) || rewriteValueAMD64_OpAMD64ORQ_100(v) || rewriteValueAMD64_OpAMD64ORQ_110(v) || rewriteValueAMD64_OpAMD64ORQ_120(v) || rewriteValueAMD64_OpAMD64ORQ_130(v) || rewriteValueAMD64_OpAMD64ORQ_140(v) || rewriteValueAMD64_OpAMD64ORQ_150(v) || psess.rewriteValueAMD64_OpAMD64ORQ_160(v)
	case OpAMD64ORQconst:
		return rewriteValueAMD64_OpAMD64ORQconst_0(v)
	case OpAMD64ORQload:
		return rewriteValueAMD64_OpAMD64ORQload_0(v)
	case OpAMD64ROLB:
		return rewriteValueAMD64_OpAMD64ROLB_0(v)
	case OpAMD64ROLBconst:
		return rewriteValueAMD64_OpAMD64ROLBconst_0(v)
	case OpAMD64ROLL:
		return rewriteValueAMD64_OpAMD64ROLL_0(v)
	case OpAMD64ROLLconst:
		return rewriteValueAMD64_OpAMD64ROLLconst_0(v)
	case OpAMD64ROLQ:
		return rewriteValueAMD64_OpAMD64ROLQ_0(v)
	case OpAMD64ROLQconst:
		return rewriteValueAMD64_OpAMD64ROLQconst_0(v)
	case OpAMD64ROLW:
		return rewriteValueAMD64_OpAMD64ROLW_0(v)
	case OpAMD64ROLWconst:
		return rewriteValueAMD64_OpAMD64ROLWconst_0(v)
	case OpAMD64RORB:
		return rewriteValueAMD64_OpAMD64RORB_0(v)
	case OpAMD64RORL:
		return rewriteValueAMD64_OpAMD64RORL_0(v)
	case OpAMD64RORQ:
		return rewriteValueAMD64_OpAMD64RORQ_0(v)
	case OpAMD64RORW:
		return rewriteValueAMD64_OpAMD64RORW_0(v)
	case OpAMD64SARB:
		return rewriteValueAMD64_OpAMD64SARB_0(v)
	case OpAMD64SARBconst:
		return rewriteValueAMD64_OpAMD64SARBconst_0(v)
	case OpAMD64SARL:
		return rewriteValueAMD64_OpAMD64SARL_0(v)
	case OpAMD64SARLconst:
		return rewriteValueAMD64_OpAMD64SARLconst_0(v)
	case OpAMD64SARQ:
		return rewriteValueAMD64_OpAMD64SARQ_0(v)
	case OpAMD64SARQconst:
		return rewriteValueAMD64_OpAMD64SARQconst_0(v)
	case OpAMD64SARW:
		return rewriteValueAMD64_OpAMD64SARW_0(v)
	case OpAMD64SARWconst:
		return rewriteValueAMD64_OpAMD64SARWconst_0(v)
	case OpAMD64SBBLcarrymask:
		return rewriteValueAMD64_OpAMD64SBBLcarrymask_0(v)
	case OpAMD64SBBQcarrymask:
		return rewriteValueAMD64_OpAMD64SBBQcarrymask_0(v)
	case OpAMD64SETA:
		return rewriteValueAMD64_OpAMD64SETA_0(v)
	case OpAMD64SETAE:
		return rewriteValueAMD64_OpAMD64SETAE_0(v)
	case OpAMD64SETAEstore:
		return rewriteValueAMD64_OpAMD64SETAEstore_0(v)
	case OpAMD64SETAstore:
		return rewriteValueAMD64_OpAMD64SETAstore_0(v)
	case OpAMD64SETB:
		return rewriteValueAMD64_OpAMD64SETB_0(v)
	case OpAMD64SETBE:
		return rewriteValueAMD64_OpAMD64SETBE_0(v)
	case OpAMD64SETBEstore:
		return rewriteValueAMD64_OpAMD64SETBEstore_0(v)
	case OpAMD64SETBstore:
		return rewriteValueAMD64_OpAMD64SETBstore_0(v)
	case OpAMD64SETEQ:
		return psess.rewriteValueAMD64_OpAMD64SETEQ_0(v) || psess.rewriteValueAMD64_OpAMD64SETEQ_10(v) || psess.rewriteValueAMD64_OpAMD64SETEQ_20(v)
	case OpAMD64SETEQstore:
		return psess.rewriteValueAMD64_OpAMD64SETEQstore_0(v) || psess.rewriteValueAMD64_OpAMD64SETEQstore_10(v) || psess.rewriteValueAMD64_OpAMD64SETEQstore_20(v)
	case OpAMD64SETG:
		return rewriteValueAMD64_OpAMD64SETG_0(v)
	case OpAMD64SETGE:
		return rewriteValueAMD64_OpAMD64SETGE_0(v)
	case OpAMD64SETGEstore:
		return rewriteValueAMD64_OpAMD64SETGEstore_0(v)
	case OpAMD64SETGstore:
		return rewriteValueAMD64_OpAMD64SETGstore_0(v)
	case OpAMD64SETL:
		return rewriteValueAMD64_OpAMD64SETL_0(v)
	case OpAMD64SETLE:
		return rewriteValueAMD64_OpAMD64SETLE_0(v)
	case OpAMD64SETLEstore:
		return rewriteValueAMD64_OpAMD64SETLEstore_0(v)
	case OpAMD64SETLstore:
		return rewriteValueAMD64_OpAMD64SETLstore_0(v)
	case OpAMD64SETNE:
		return psess.rewriteValueAMD64_OpAMD64SETNE_0(v) || psess.rewriteValueAMD64_OpAMD64SETNE_10(v) || psess.rewriteValueAMD64_OpAMD64SETNE_20(v)
	case OpAMD64SETNEstore:
		return psess.rewriteValueAMD64_OpAMD64SETNEstore_0(v) || psess.rewriteValueAMD64_OpAMD64SETNEstore_10(v) || psess.rewriteValueAMD64_OpAMD64SETNEstore_20(v)
	case OpAMD64SHLL:
		return rewriteValueAMD64_OpAMD64SHLL_0(v)
	case OpAMD64SHLLconst:
		return rewriteValueAMD64_OpAMD64SHLLconst_0(v)
	case OpAMD64SHLQ:
		return rewriteValueAMD64_OpAMD64SHLQ_0(v)
	case OpAMD64SHLQconst:
		return rewriteValueAMD64_OpAMD64SHLQconst_0(v)
	case OpAMD64SHRB:
		return rewriteValueAMD64_OpAMD64SHRB_0(v)
	case OpAMD64SHRBconst:
		return rewriteValueAMD64_OpAMD64SHRBconst_0(v)
	case OpAMD64SHRL:
		return rewriteValueAMD64_OpAMD64SHRL_0(v)
	case OpAMD64SHRLconst:
		return rewriteValueAMD64_OpAMD64SHRLconst_0(v)
	case OpAMD64SHRQ:
		return rewriteValueAMD64_OpAMD64SHRQ_0(v)
	case OpAMD64SHRQconst:
		return rewriteValueAMD64_OpAMD64SHRQconst_0(v)
	case OpAMD64SHRW:
		return rewriteValueAMD64_OpAMD64SHRW_0(v)
	case OpAMD64SHRWconst:
		return rewriteValueAMD64_OpAMD64SHRWconst_0(v)
	case OpAMD64SUBL:
		return psess.rewriteValueAMD64_OpAMD64SUBL_0(v)
	case OpAMD64SUBLconst:
		return rewriteValueAMD64_OpAMD64SUBLconst_0(v)
	case OpAMD64SUBLload:
		return rewriteValueAMD64_OpAMD64SUBLload_0(v)
	case OpAMD64SUBQ:
		return psess.rewriteValueAMD64_OpAMD64SUBQ_0(v)
	case OpAMD64SUBQconst:
		return rewriteValueAMD64_OpAMD64SUBQconst_0(v)
	case OpAMD64SUBQload:
		return rewriteValueAMD64_OpAMD64SUBQload_0(v)
	case OpAMD64SUBSD:
		return psess.rewriteValueAMD64_OpAMD64SUBSD_0(v)
	case OpAMD64SUBSDload:
		return rewriteValueAMD64_OpAMD64SUBSDload_0(v)
	case OpAMD64SUBSS:
		return psess.rewriteValueAMD64_OpAMD64SUBSS_0(v)
	case OpAMD64SUBSSload:
		return rewriteValueAMD64_OpAMD64SUBSSload_0(v)
	case OpAMD64TESTB:
		return psess.rewriteValueAMD64_OpAMD64TESTB_0(v)
	case OpAMD64TESTBconst:
		return rewriteValueAMD64_OpAMD64TESTBconst_0(v)
	case OpAMD64TESTL:
		return psess.rewriteValueAMD64_OpAMD64TESTL_0(v)
	case OpAMD64TESTLconst:
		return rewriteValueAMD64_OpAMD64TESTLconst_0(v)
	case OpAMD64TESTQ:
		return psess.rewriteValueAMD64_OpAMD64TESTQ_0(v)
	case OpAMD64TESTQconst:
		return rewriteValueAMD64_OpAMD64TESTQconst_0(v)
	case OpAMD64TESTW:
		return psess.rewriteValueAMD64_OpAMD64TESTW_0(v)
	case OpAMD64TESTWconst:
		return rewriteValueAMD64_OpAMD64TESTWconst_0(v)
	case OpAMD64XADDLlock:
		return rewriteValueAMD64_OpAMD64XADDLlock_0(v)
	case OpAMD64XADDQlock:
		return rewriteValueAMD64_OpAMD64XADDQlock_0(v)
	case OpAMD64XCHGL:
		return rewriteValueAMD64_OpAMD64XCHGL_0(v)
	case OpAMD64XCHGQ:
		return rewriteValueAMD64_OpAMD64XCHGQ_0(v)
	case OpAMD64XORL:
		return psess.rewriteValueAMD64_OpAMD64XORL_0(v) || psess.rewriteValueAMD64_OpAMD64XORL_10(v)
	case OpAMD64XORLconst:
		return rewriteValueAMD64_OpAMD64XORLconst_0(v) || rewriteValueAMD64_OpAMD64XORLconst_10(v)
	case OpAMD64XORLload:
		return rewriteValueAMD64_OpAMD64XORLload_0(v)
	case OpAMD64XORQ:
		return psess.rewriteValueAMD64_OpAMD64XORQ_0(v) || psess.rewriteValueAMD64_OpAMD64XORQ_10(v)
	case OpAMD64XORQconst:
		return rewriteValueAMD64_OpAMD64XORQconst_0(v)
	case OpAMD64XORQload:
		return rewriteValueAMD64_OpAMD64XORQload_0(v)
	case OpAdd16:
		return rewriteValueAMD64_OpAdd16_0(v)
	case OpAdd32:
		return rewriteValueAMD64_OpAdd32_0(v)
	case OpAdd32F:
		return rewriteValueAMD64_OpAdd32F_0(v)
	case OpAdd64:
		return rewriteValueAMD64_OpAdd64_0(v)
	case OpAdd64F:
		return rewriteValueAMD64_OpAdd64F_0(v)
	case OpAdd8:
		return rewriteValueAMD64_OpAdd8_0(v)
	case OpAddPtr:
		return rewriteValueAMD64_OpAddPtr_0(v)
	case OpAddr:
		return rewriteValueAMD64_OpAddr_0(v)
	case OpAnd16:
		return rewriteValueAMD64_OpAnd16_0(v)
	case OpAnd32:
		return rewriteValueAMD64_OpAnd32_0(v)
	case OpAnd64:
		return rewriteValueAMD64_OpAnd64_0(v)
	case OpAnd8:
		return rewriteValueAMD64_OpAnd8_0(v)
	case OpAndB:
		return rewriteValueAMD64_OpAndB_0(v)
	case OpAtomicAdd32:
		return psess.rewriteValueAMD64_OpAtomicAdd32_0(v)
	case OpAtomicAdd64:
		return psess.rewriteValueAMD64_OpAtomicAdd64_0(v)
	case OpAtomicAnd8:
		return rewriteValueAMD64_OpAtomicAnd8_0(v)
	case OpAtomicCompareAndSwap32:
		return rewriteValueAMD64_OpAtomicCompareAndSwap32_0(v)
	case OpAtomicCompareAndSwap64:
		return rewriteValueAMD64_OpAtomicCompareAndSwap64_0(v)
	case OpAtomicExchange32:
		return rewriteValueAMD64_OpAtomicExchange32_0(v)
	case OpAtomicExchange64:
		return rewriteValueAMD64_OpAtomicExchange64_0(v)
	case OpAtomicLoad32:
		return rewriteValueAMD64_OpAtomicLoad32_0(v)
	case OpAtomicLoad64:
		return rewriteValueAMD64_OpAtomicLoad64_0(v)
	case OpAtomicLoadPtr:
		return rewriteValueAMD64_OpAtomicLoadPtr_0(v)
	case OpAtomicOr8:
		return rewriteValueAMD64_OpAtomicOr8_0(v)
	case OpAtomicStore32:
		return psess.rewriteValueAMD64_OpAtomicStore32_0(v)
	case OpAtomicStore64:
		return psess.rewriteValueAMD64_OpAtomicStore64_0(v)
	case OpAtomicStorePtrNoWB:
		return psess.rewriteValueAMD64_OpAtomicStorePtrNoWB_0(v)
	case OpAvg64u:
		return rewriteValueAMD64_OpAvg64u_0(v)
	case OpBitLen16:
		return rewriteValueAMD64_OpBitLen16_0(v)
	case OpBitLen32:
		return psess.rewriteValueAMD64_OpBitLen32_0(v)
	case OpBitLen64:
		return psess.rewriteValueAMD64_OpBitLen64_0(v)
	case OpBitLen8:
		return rewriteValueAMD64_OpBitLen8_0(v)
	case OpBswap32:
		return rewriteValueAMD64_OpBswap32_0(v)
	case OpBswap64:
		return rewriteValueAMD64_OpBswap64_0(v)
	case OpCeil:
		return rewriteValueAMD64_OpCeil_0(v)
	case OpClosureCall:
		return rewriteValueAMD64_OpClosureCall_0(v)
	case OpCom16:
		return rewriteValueAMD64_OpCom16_0(v)
	case OpCom32:
		return rewriteValueAMD64_OpCom32_0(v)
	case OpCom64:
		return rewriteValueAMD64_OpCom64_0(v)
	case OpCom8:
		return rewriteValueAMD64_OpCom8_0(v)
	case OpCondSelect:
		return psess.rewriteValueAMD64_OpCondSelect_0(v) || psess.rewriteValueAMD64_OpCondSelect_10(v) || psess.rewriteValueAMD64_OpCondSelect_20(v) || psess.rewriteValueAMD64_OpCondSelect_30(v) || psess.rewriteValueAMD64_OpCondSelect_40(v)
	case OpConst16:
		return rewriteValueAMD64_OpConst16_0(v)
	case OpConst32:
		return rewriteValueAMD64_OpConst32_0(v)
	case OpConst32F:
		return rewriteValueAMD64_OpConst32F_0(v)
	case OpConst64:
		return rewriteValueAMD64_OpConst64_0(v)
	case OpConst64F:
		return rewriteValueAMD64_OpConst64F_0(v)
	case OpConst8:
		return rewriteValueAMD64_OpConst8_0(v)
	case OpConstBool:
		return rewriteValueAMD64_OpConstBool_0(v)
	case OpConstNil:
		return rewriteValueAMD64_OpConstNil_0(v)
	case OpCtz16:
		return rewriteValueAMD64_OpCtz16_0(v)
	case OpCtz16NonZero:
		return rewriteValueAMD64_OpCtz16NonZero_0(v)
	case OpCtz32:
		return psess.rewriteValueAMD64_OpCtz32_0(v)
	case OpCtz32NonZero:
		return rewriteValueAMD64_OpCtz32NonZero_0(v)
	case OpCtz64:
		return psess.rewriteValueAMD64_OpCtz64_0(v)
	case OpCtz64NonZero:
		return psess.rewriteValueAMD64_OpCtz64NonZero_0(v)
	case OpCtz8:
		return rewriteValueAMD64_OpCtz8_0(v)
	case OpCtz8NonZero:
		return rewriteValueAMD64_OpCtz8NonZero_0(v)
	case OpCvt32Fto32:
		return rewriteValueAMD64_OpCvt32Fto32_0(v)
	case OpCvt32Fto64:
		return rewriteValueAMD64_OpCvt32Fto64_0(v)
	case OpCvt32Fto64F:
		return rewriteValueAMD64_OpCvt32Fto64F_0(v)
	case OpCvt32to32F:
		return rewriteValueAMD64_OpCvt32to32F_0(v)
	case OpCvt32to64F:
		return rewriteValueAMD64_OpCvt32to64F_0(v)
	case OpCvt64Fto32:
		return rewriteValueAMD64_OpCvt64Fto32_0(v)
	case OpCvt64Fto32F:
		return rewriteValueAMD64_OpCvt64Fto32F_0(v)
	case OpCvt64Fto64:
		return rewriteValueAMD64_OpCvt64Fto64_0(v)
	case OpCvt64to32F:
		return rewriteValueAMD64_OpCvt64to32F_0(v)
	case OpCvt64to64F:
		return rewriteValueAMD64_OpCvt64to64F_0(v)
	case OpDiv128u:
		return rewriteValueAMD64_OpDiv128u_0(v)
	case OpDiv16:
		return rewriteValueAMD64_OpDiv16_0(v)
	case OpDiv16u:
		return rewriteValueAMD64_OpDiv16u_0(v)
	case OpDiv32:
		return rewriteValueAMD64_OpDiv32_0(v)
	case OpDiv32F:
		return rewriteValueAMD64_OpDiv32F_0(v)
	case OpDiv32u:
		return rewriteValueAMD64_OpDiv32u_0(v)
	case OpDiv64:
		return rewriteValueAMD64_OpDiv64_0(v)
	case OpDiv64F:
		return rewriteValueAMD64_OpDiv64F_0(v)
	case OpDiv64u:
		return rewriteValueAMD64_OpDiv64u_0(v)
	case OpDiv8:
		return rewriteValueAMD64_OpDiv8_0(v)
	case OpDiv8u:
		return rewriteValueAMD64_OpDiv8u_0(v)
	case OpEq16:
		return psess.rewriteValueAMD64_OpEq16_0(v)
	case OpEq32:
		return psess.rewriteValueAMD64_OpEq32_0(v)
	case OpEq32F:
		return psess.rewriteValueAMD64_OpEq32F_0(v)
	case OpEq64:
		return psess.rewriteValueAMD64_OpEq64_0(v)
	case OpEq64F:
		return psess.rewriteValueAMD64_OpEq64F_0(v)
	case OpEq8:
		return psess.rewriteValueAMD64_OpEq8_0(v)
	case OpEqB:
		return psess.rewriteValueAMD64_OpEqB_0(v)
	case OpEqPtr:
		return psess.rewriteValueAMD64_OpEqPtr_0(v)
	case OpFloor:
		return rewriteValueAMD64_OpFloor_0(v)
	case OpGeq16:
		return psess.rewriteValueAMD64_OpGeq16_0(v)
	case OpGeq16U:
		return psess.rewriteValueAMD64_OpGeq16U_0(v)
	case OpGeq32:
		return psess.rewriteValueAMD64_OpGeq32_0(v)
	case OpGeq32F:
		return psess.rewriteValueAMD64_OpGeq32F_0(v)
	case OpGeq32U:
		return psess.rewriteValueAMD64_OpGeq32U_0(v)
	case OpGeq64:
		return psess.rewriteValueAMD64_OpGeq64_0(v)
	case OpGeq64F:
		return psess.rewriteValueAMD64_OpGeq64F_0(v)
	case OpGeq64U:
		return psess.rewriteValueAMD64_OpGeq64U_0(v)
	case OpGeq8:
		return psess.rewriteValueAMD64_OpGeq8_0(v)
	case OpGeq8U:
		return psess.rewriteValueAMD64_OpGeq8U_0(v)
	case OpGetCallerPC:
		return rewriteValueAMD64_OpGetCallerPC_0(v)
	case OpGetCallerSP:
		return rewriteValueAMD64_OpGetCallerSP_0(v)
	case OpGetClosurePtr:
		return rewriteValueAMD64_OpGetClosurePtr_0(v)
	case OpGetG:
		return rewriteValueAMD64_OpGetG_0(v)
	case OpGreater16:
		return psess.rewriteValueAMD64_OpGreater16_0(v)
	case OpGreater16U:
		return psess.rewriteValueAMD64_OpGreater16U_0(v)
	case OpGreater32:
		return psess.rewriteValueAMD64_OpGreater32_0(v)
	case OpGreater32F:
		return psess.rewriteValueAMD64_OpGreater32F_0(v)
	case OpGreater32U:
		return psess.rewriteValueAMD64_OpGreater32U_0(v)
	case OpGreater64:
		return psess.rewriteValueAMD64_OpGreater64_0(v)
	case OpGreater64F:
		return psess.rewriteValueAMD64_OpGreater64F_0(v)
	case OpGreater64U:
		return psess.rewriteValueAMD64_OpGreater64U_0(v)
	case OpGreater8:
		return psess.rewriteValueAMD64_OpGreater8_0(v)
	case OpGreater8U:
		return psess.rewriteValueAMD64_OpGreater8U_0(v)
	case OpHmul32:
		return rewriteValueAMD64_OpHmul32_0(v)
	case OpHmul32u:
		return rewriteValueAMD64_OpHmul32u_0(v)
	case OpHmul64:
		return rewriteValueAMD64_OpHmul64_0(v)
	case OpHmul64u:
		return rewriteValueAMD64_OpHmul64u_0(v)
	case OpInt64Hi:
		return rewriteValueAMD64_OpInt64Hi_0(v)
	case OpInterCall:
		return rewriteValueAMD64_OpInterCall_0(v)
	case OpIsInBounds:
		return psess.rewriteValueAMD64_OpIsInBounds_0(v)
	case OpIsNonNil:
		return psess.rewriteValueAMD64_OpIsNonNil_0(v)
	case OpIsSliceInBounds:
		return psess.rewriteValueAMD64_OpIsSliceInBounds_0(v)
	case OpLeq16:
		return psess.rewriteValueAMD64_OpLeq16_0(v)
	case OpLeq16U:
		return psess.rewriteValueAMD64_OpLeq16U_0(v)
	case OpLeq32:
		return psess.rewriteValueAMD64_OpLeq32_0(v)
	case OpLeq32F:
		return psess.rewriteValueAMD64_OpLeq32F_0(v)
	case OpLeq32U:
		return psess.rewriteValueAMD64_OpLeq32U_0(v)
	case OpLeq64:
		return psess.rewriteValueAMD64_OpLeq64_0(v)
	case OpLeq64F:
		return psess.rewriteValueAMD64_OpLeq64F_0(v)
	case OpLeq64U:
		return psess.rewriteValueAMD64_OpLeq64U_0(v)
	case OpLeq8:
		return psess.rewriteValueAMD64_OpLeq8_0(v)
	case OpLeq8U:
		return psess.rewriteValueAMD64_OpLeq8U_0(v)
	case OpLess16:
		return psess.rewriteValueAMD64_OpLess16_0(v)
	case OpLess16U:
		return psess.rewriteValueAMD64_OpLess16U_0(v)
	case OpLess32:
		return psess.rewriteValueAMD64_OpLess32_0(v)
	case OpLess32F:
		return psess.rewriteValueAMD64_OpLess32F_0(v)
	case OpLess32U:
		return psess.rewriteValueAMD64_OpLess32U_0(v)
	case OpLess64:
		return psess.rewriteValueAMD64_OpLess64_0(v)
	case OpLess64F:
		return psess.rewriteValueAMD64_OpLess64F_0(v)
	case OpLess64U:
		return psess.rewriteValueAMD64_OpLess64U_0(v)
	case OpLess8:
		return psess.rewriteValueAMD64_OpLess8_0(v)
	case OpLess8U:
		return psess.rewriteValueAMD64_OpLess8U_0(v)
	case OpLoad:
		return psess.rewriteValueAMD64_OpLoad_0(v)
	case OpLsh16x16:
		return psess.rewriteValueAMD64_OpLsh16x16_0(v)
	case OpLsh16x32:
		return psess.rewriteValueAMD64_OpLsh16x32_0(v)
	case OpLsh16x64:
		return psess.rewriteValueAMD64_OpLsh16x64_0(v)
	case OpLsh16x8:
		return psess.rewriteValueAMD64_OpLsh16x8_0(v)
	case OpLsh32x16:
		return psess.rewriteValueAMD64_OpLsh32x16_0(v)
	case OpLsh32x32:
		return psess.rewriteValueAMD64_OpLsh32x32_0(v)
	case OpLsh32x64:
		return psess.rewriteValueAMD64_OpLsh32x64_0(v)
	case OpLsh32x8:
		return psess.rewriteValueAMD64_OpLsh32x8_0(v)
	case OpLsh64x16:
		return psess.rewriteValueAMD64_OpLsh64x16_0(v)
	case OpLsh64x32:
		return psess.rewriteValueAMD64_OpLsh64x32_0(v)
	case OpLsh64x64:
		return psess.rewriteValueAMD64_OpLsh64x64_0(v)
	case OpLsh64x8:
		return psess.rewriteValueAMD64_OpLsh64x8_0(v)
	case OpLsh8x16:
		return psess.rewriteValueAMD64_OpLsh8x16_0(v)
	case OpLsh8x32:
		return psess.rewriteValueAMD64_OpLsh8x32_0(v)
	case OpLsh8x64:
		return psess.rewriteValueAMD64_OpLsh8x64_0(v)
	case OpLsh8x8:
		return psess.rewriteValueAMD64_OpLsh8x8_0(v)
	case OpMod16:
		return rewriteValueAMD64_OpMod16_0(v)
	case OpMod16u:
		return rewriteValueAMD64_OpMod16u_0(v)
	case OpMod32:
		return rewriteValueAMD64_OpMod32_0(v)
	case OpMod32u:
		return rewriteValueAMD64_OpMod32u_0(v)
	case OpMod64:
		return rewriteValueAMD64_OpMod64_0(v)
	case OpMod64u:
		return rewriteValueAMD64_OpMod64u_0(v)
	case OpMod8:
		return rewriteValueAMD64_OpMod8_0(v)
	case OpMod8u:
		return rewriteValueAMD64_OpMod8u_0(v)
	case OpMove:
		return psess.rewriteValueAMD64_OpMove_0(v) || psess.rewriteValueAMD64_OpMove_10(v)
	case OpMul16:
		return rewriteValueAMD64_OpMul16_0(v)
	case OpMul32:
		return rewriteValueAMD64_OpMul32_0(v)
	case OpMul32F:
		return rewriteValueAMD64_OpMul32F_0(v)
	case OpMul64:
		return rewriteValueAMD64_OpMul64_0(v)
	case OpMul64F:
		return rewriteValueAMD64_OpMul64F_0(v)
	case OpMul64uhilo:
		return rewriteValueAMD64_OpMul64uhilo_0(v)
	case OpMul8:
		return rewriteValueAMD64_OpMul8_0(v)
	case OpNeg16:
		return rewriteValueAMD64_OpNeg16_0(v)
	case OpNeg32:
		return rewriteValueAMD64_OpNeg32_0(v)
	case OpNeg32F:
		return rewriteValueAMD64_OpNeg32F_0(v)
	case OpNeg64:
		return rewriteValueAMD64_OpNeg64_0(v)
	case OpNeg64F:
		return rewriteValueAMD64_OpNeg64F_0(v)
	case OpNeg8:
		return rewriteValueAMD64_OpNeg8_0(v)
	case OpNeq16:
		return psess.rewriteValueAMD64_OpNeq16_0(v)
	case OpNeq32:
		return psess.rewriteValueAMD64_OpNeq32_0(v)
	case OpNeq32F:
		return psess.rewriteValueAMD64_OpNeq32F_0(v)
	case OpNeq64:
		return psess.rewriteValueAMD64_OpNeq64_0(v)
	case OpNeq64F:
		return psess.rewriteValueAMD64_OpNeq64F_0(v)
	case OpNeq8:
		return psess.rewriteValueAMD64_OpNeq8_0(v)
	case OpNeqB:
		return psess.rewriteValueAMD64_OpNeqB_0(v)
	case OpNeqPtr:
		return psess.rewriteValueAMD64_OpNeqPtr_0(v)
	case OpNilCheck:
		return rewriteValueAMD64_OpNilCheck_0(v)
	case OpNot:
		return rewriteValueAMD64_OpNot_0(v)
	case OpOffPtr:
		return rewriteValueAMD64_OpOffPtr_0(v)
	case OpOr16:
		return rewriteValueAMD64_OpOr16_0(v)
	case OpOr32:
		return rewriteValueAMD64_OpOr32_0(v)
	case OpOr64:
		return rewriteValueAMD64_OpOr64_0(v)
	case OpOr8:
		return rewriteValueAMD64_OpOr8_0(v)
	case OpOrB:
		return rewriteValueAMD64_OpOrB_0(v)
	case OpPopCount16:
		return rewriteValueAMD64_OpPopCount16_0(v)
	case OpPopCount32:
		return rewriteValueAMD64_OpPopCount32_0(v)
	case OpPopCount64:
		return rewriteValueAMD64_OpPopCount64_0(v)
	case OpPopCount8:
		return rewriteValueAMD64_OpPopCount8_0(v)
	case OpRound32F:
		return rewriteValueAMD64_OpRound32F_0(v)
	case OpRound64F:
		return rewriteValueAMD64_OpRound64F_0(v)
	case OpRoundToEven:
		return rewriteValueAMD64_OpRoundToEven_0(v)
	case OpRsh16Ux16:
		return psess.rewriteValueAMD64_OpRsh16Ux16_0(v)
	case OpRsh16Ux32:
		return psess.rewriteValueAMD64_OpRsh16Ux32_0(v)
	case OpRsh16Ux64:
		return psess.rewriteValueAMD64_OpRsh16Ux64_0(v)
	case OpRsh16Ux8:
		return psess.rewriteValueAMD64_OpRsh16Ux8_0(v)
	case OpRsh16x16:
		return psess.rewriteValueAMD64_OpRsh16x16_0(v)
	case OpRsh16x32:
		return psess.rewriteValueAMD64_OpRsh16x32_0(v)
	case OpRsh16x64:
		return psess.rewriteValueAMD64_OpRsh16x64_0(v)
	case OpRsh16x8:
		return psess.rewriteValueAMD64_OpRsh16x8_0(v)
	case OpRsh32Ux16:
		return psess.rewriteValueAMD64_OpRsh32Ux16_0(v)
	case OpRsh32Ux32:
		return psess.rewriteValueAMD64_OpRsh32Ux32_0(v)
	case OpRsh32Ux64:
		return psess.rewriteValueAMD64_OpRsh32Ux64_0(v)
	case OpRsh32Ux8:
		return psess.rewriteValueAMD64_OpRsh32Ux8_0(v)
	case OpRsh32x16:
		return psess.rewriteValueAMD64_OpRsh32x16_0(v)
	case OpRsh32x32:
		return psess.rewriteValueAMD64_OpRsh32x32_0(v)
	case OpRsh32x64:
		return psess.rewriteValueAMD64_OpRsh32x64_0(v)
	case OpRsh32x8:
		return psess.rewriteValueAMD64_OpRsh32x8_0(v)
	case OpRsh64Ux16:
		return psess.rewriteValueAMD64_OpRsh64Ux16_0(v)
	case OpRsh64Ux32:
		return psess.rewriteValueAMD64_OpRsh64Ux32_0(v)
	case OpRsh64Ux64:
		return psess.rewriteValueAMD64_OpRsh64Ux64_0(v)
	case OpRsh64Ux8:
		return psess.rewriteValueAMD64_OpRsh64Ux8_0(v)
	case OpRsh64x16:
		return psess.rewriteValueAMD64_OpRsh64x16_0(v)
	case OpRsh64x32:
		return psess.rewriteValueAMD64_OpRsh64x32_0(v)
	case OpRsh64x64:
		return psess.rewriteValueAMD64_OpRsh64x64_0(v)
	case OpRsh64x8:
		return psess.rewriteValueAMD64_OpRsh64x8_0(v)
	case OpRsh8Ux16:
		return psess.rewriteValueAMD64_OpRsh8Ux16_0(v)
	case OpRsh8Ux32:
		return psess.rewriteValueAMD64_OpRsh8Ux32_0(v)
	case OpRsh8Ux64:
		return psess.rewriteValueAMD64_OpRsh8Ux64_0(v)
	case OpRsh8Ux8:
		return psess.rewriteValueAMD64_OpRsh8Ux8_0(v)
	case OpRsh8x16:
		return psess.rewriteValueAMD64_OpRsh8x16_0(v)
	case OpRsh8x32:
		return psess.rewriteValueAMD64_OpRsh8x32_0(v)
	case OpRsh8x64:
		return psess.rewriteValueAMD64_OpRsh8x64_0(v)
	case OpRsh8x8:
		return psess.rewriteValueAMD64_OpRsh8x8_0(v)
	case OpSelect0:
		return rewriteValueAMD64_OpSelect0_0(v)
	case OpSelect1:
		return rewriteValueAMD64_OpSelect1_0(v)
	case OpSignExt16to32:
		return rewriteValueAMD64_OpSignExt16to32_0(v)
	case OpSignExt16to64:
		return rewriteValueAMD64_OpSignExt16to64_0(v)
	case OpSignExt32to64:
		return rewriteValueAMD64_OpSignExt32to64_0(v)
	case OpSignExt8to16:
		return rewriteValueAMD64_OpSignExt8to16_0(v)
	case OpSignExt8to32:
		return rewriteValueAMD64_OpSignExt8to32_0(v)
	case OpSignExt8to64:
		return rewriteValueAMD64_OpSignExt8to64_0(v)
	case OpSlicemask:
		return rewriteValueAMD64_OpSlicemask_0(v)
	case OpSqrt:
		return rewriteValueAMD64_OpSqrt_0(v)
	case OpStaticCall:
		return rewriteValueAMD64_OpStaticCall_0(v)
	case OpStore:
		return psess.rewriteValueAMD64_OpStore_0(v)
	case OpSub16:
		return rewriteValueAMD64_OpSub16_0(v)
	case OpSub32:
		return rewriteValueAMD64_OpSub32_0(v)
	case OpSub32F:
		return rewriteValueAMD64_OpSub32F_0(v)
	case OpSub64:
		return rewriteValueAMD64_OpSub64_0(v)
	case OpSub64F:
		return rewriteValueAMD64_OpSub64F_0(v)
	case OpSub8:
		return rewriteValueAMD64_OpSub8_0(v)
	case OpSubPtr:
		return rewriteValueAMD64_OpSubPtr_0(v)
	case OpTrunc:
		return rewriteValueAMD64_OpTrunc_0(v)
	case OpTrunc16to8:
		return rewriteValueAMD64_OpTrunc16to8_0(v)
	case OpTrunc32to16:
		return rewriteValueAMD64_OpTrunc32to16_0(v)
	case OpTrunc32to8:
		return rewriteValueAMD64_OpTrunc32to8_0(v)
	case OpTrunc64to16:
		return rewriteValueAMD64_OpTrunc64to16_0(v)
	case OpTrunc64to32:
		return rewriteValueAMD64_OpTrunc64to32_0(v)
	case OpTrunc64to8:
		return rewriteValueAMD64_OpTrunc64to8_0(v)
	case OpWB:
		return rewriteValueAMD64_OpWB_0(v)
	case OpXor16:
		return rewriteValueAMD64_OpXor16_0(v)
	case OpXor32:
		return rewriteValueAMD64_OpXor32_0(v)
	case OpXor64:
		return rewriteValueAMD64_OpXor64_0(v)
	case OpXor8:
		return rewriteValueAMD64_OpXor8_0(v)
	case OpZero:
		return psess.rewriteValueAMD64_OpZero_0(v) || psess.rewriteValueAMD64_OpZero_10(v) || psess.rewriteValueAMD64_OpZero_20(v)
	case OpZeroExt16to32:
		return rewriteValueAMD64_OpZeroExt16to32_0(v)
	case OpZeroExt16to64:
		return rewriteValueAMD64_OpZeroExt16to64_0(v)
	case OpZeroExt32to64:
		return rewriteValueAMD64_OpZeroExt32to64_0(v)
	case OpZeroExt8to16:
		return rewriteValueAMD64_OpZeroExt8to16_0(v)
	case OpZeroExt8to32:
		return rewriteValueAMD64_OpZeroExt8to32_0(v)
	case OpZeroExt8to64:
		return rewriteValueAMD64_OpZeroExt8to64_0(v)
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ADDL_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRWconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRWconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRBconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRBconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDL_10(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 2 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDL {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDL {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		if y != v_0.Args[1] {
			break
		}
		x := v.Args[1]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		y := v_1.Args[1]
		v.reset(OpAMD64LEAL2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDL {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		if x != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDL {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		x := v_0.Args[1]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ADDL_20(v *Value) bool {

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		y := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAL {
			break
		}
		c := v_1.AuxInt
		s := v_1.Aux
		y := v_1.Args[0]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		c := v_0.AuxInt
		s := v_0.Aux
		y := v_0.Args[0]
		x := v.Args[1]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGL {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		x := v_0.Args[0]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL1 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL2 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL4 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL8 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(int32(c) == 0) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = int64(int32(c + d))
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = int64(int32(c + d))
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDLconst_10(v *Value) bool {

	for {
		off := v.AuxInt
		x := v.Args[0]
		if x.Op != OpSP {
			break
		}
		v.reset(OpAMD64LEAL)
		v.AuxInt = off
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDLconstmodify_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		valoff1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(valoff1).canAdd(off2)) {
			break
		}
		v.reset(OpAMD64ADDLconstmodify)
		v.AuxInt = ValAndOff(valoff1).add(off2)
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		valoff1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(valoff1).canAdd(off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDLconstmodify)
		v.AuxInt = ValAndOff(valoff1).add(off2)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		valOff := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVSSstore {
			break
		}
		if v_1.AuxInt != ValAndOff(valOff).Off() {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		x := v_1.Args[1]
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = ValAndOff(valOff).Val()
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDLload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ADDLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSSstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ADDL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQ_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 2 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQ_10(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQ {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		if y != v_0.Args[1] {
			break
		}
		x := v.Args[1]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		y := v_1.Args[1]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQ {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		if x != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		x := v_0.Args[1]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		y := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		c := v_1.AuxInt
		s := v_1.Aux
		y := v_1.Args[0]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		c := v_0.AuxInt
		s := v_0.Aux
		y := v_0.Args[0]
		x := v.Args[1]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ADDQ_20(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64SUBQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGQ {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64SUBQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		x := v_0.Args[0]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ2 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		d := v_0.AuxInt
		s := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = c + d
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = c + d
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQconst_10(v *Value) bool {

	for {
		off := v.AuxInt
		x := v.Args[0]
		if x.Op != OpSP {
			break
		}
		v.reset(OpAMD64LEAQ)
		v.AuxInt = off
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQconstmodify_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		valoff1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(valoff1).canAdd(off2)) {
			break
		}
		v.reset(OpAMD64ADDQconstmodify)
		v.AuxInt = ValAndOff(valoff1).add(off2)
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		valoff1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(valoff1).canAdd(off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDQconstmodify)
		v.AuxInt = ValAndOff(valoff1).add(off2)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		valOff := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVSDstore {
			break
		}
		if v_1.AuxInt != ValAndOff(valOff).Off() {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		x := v_1.Args[1]
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = ValAndOff(valOff).Val()
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDQload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ADDQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSDstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ADDQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ADDSD_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSDload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDSDload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVSDload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDSDload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDSDload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ADDSDload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDSDload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVQstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ADDSD)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ADDSS_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSSload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDSSload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVSSload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ADDSSload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ADDSSload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ADDSSload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ADDSSload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVLstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ADDSS)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ANDL_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NOTL {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		y := v_0_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NOTL {
			break
		}
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		y := v_1_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint32PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = log2uint32(^c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint32PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = log2uint32(^c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ANDLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ANDLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ANDLconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint32PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = log2uint32(^c)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0xFF {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0xFFFF {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		if !(int32(c) == 0) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(int32(c) == -1) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = c & d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ANDLload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ANDLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ANDLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSSstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ANDL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ANDQ_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NOTQ {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		y := v_0_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NOTQ {
			break
		}
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		y := v_1_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint64PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = log2(^c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint64PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = log2(^c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ANDQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ANDQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ANDQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ANDQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ANDQconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint64PowerOfTwo(^c) && uint64(^c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = log2(^c)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ANDQconst)
		v.AuxInt = c & d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0xFF {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0xFFFF {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0xFFFFFFFF {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64MOVLQZX)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = c & d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ANDQload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ANDQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ANDQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSDstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ANDQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BSFQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ORQconst {
			break
		}
		t := v_0.Type
		if v_0.AuxInt != 1<<8 {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVBQZX {
			break
		}
		x := v_0_0.Args[0]
		v.reset(OpAMD64BSFQ)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQconst, t)
		v0.AuxInt = 1 << 8
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ORQconst {
			break
		}
		t := v_0.Type
		if v_0.AuxInt != 1<<16 {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVWQZX {
			break
		}
		x := v_0_0.Args[0]
		v.reset(OpAMD64BSFQ)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQconst, t)
		v0.AuxInt = 1 << 16
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !((c + d) < 64) {
			break
		}
		v.reset(OpAMD64BTQconst)
		v.AuxInt = c + d
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(c > d) {
			break
		}
		v.reset(OpAMD64BTLconst)
		v.AuxInt = c - d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		s := v.Args[0]
		if s.Op != OpAMD64SHRQ {
			break
		}
		_ = s.Args[1]
		x := s.Args[0]
		y := s.Args[1]
		v.reset(OpAMD64BTQ)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !((c + d) < 32) {
			break
		}
		v.reset(OpAMD64BTLconst)
		v.AuxInt = c + d
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(c > d) {
			break
		}
		v.reset(OpAMD64BTLconst)
		v.AuxInt = c - d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		s := v.Args[0]
		if s.Op != OpAMD64SHRL {
			break
		}
		_ = s.Args[1]
		x := s.Args[0]
		y := s.Args[1]
		v.reset(OpAMD64BTL)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTQconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !((c + d) < 64) {
			break
		}
		v.reset(OpAMD64BTQconst)
		v.AuxInt = c + d
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(c > d) {
			break
		}
		v.reset(OpAMD64BTQconst)
		v.AuxInt = c - d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		s := v.Args[0]
		if s.Op != OpAMD64SHRQ {
			break
		}
		_ = s.Args[1]
		x := s.Args[0]
		y := s.Args[1]
		v.reset(OpAMD64BTQ)
		v.AddArg(y)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTRLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTSLconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTCLconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTRQconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTSQconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTCQconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTSLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTRLconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTSLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTCLconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTSLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64BTSQconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTRQconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTSQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64BTCQconst {
			break
		}
		if v_0.AuxInt != c {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64BTSQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLCC_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLLS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLCS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLHI)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLEQ_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLEQ)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLGE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLLE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLGT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLLT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLHI_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLCS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLLE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLGE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLLS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLCC)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLLT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLGT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVLNE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVLNE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQCC_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQLS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQCS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQHI)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQEQ_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQEQ)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpSelect1 {
			break
		}
		v_2_0 := v_2.Args[0]
		if v_2_0.Op != OpAMD64BSFQ {
			break
		}
		v_2_0_0 := v_2_0.Args[0]
		if v_2_0_0.Op != OpAMD64ORQconst {
			break
		}
		c := v_2_0_0.AuxInt
		if !(c != 0) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQGE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQLE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQGT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQLT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQHI_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQCS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQLE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQGE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQLS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQCC)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQLT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQGT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVQNE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVQNE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWCC_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWLS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWCS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWHI)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWEQ_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWEQ)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWGE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWLE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWGT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWLT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWHI_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWCS)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWLE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWGE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWLS_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWCC)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWLT_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWGT)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMOVWNE_0(v *Value) bool {

	for {
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64InvertFlags {
			break
		}
		cond := v_2.Args[0]
		v.reset(OpAMD64CMOVWNE)
		v.AddArg(x)
		v.AddArg(y)
		v.AddArg(cond)
		return true
	}

	for {
		_ = v.Args[2]
		y := v.Args[0]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpCopy)
		v.Type = y.Type
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[2]
		x := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPB_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64CMPBconst)
		v.AuxInt = int64(int8(c))
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v0.AuxInt = int64(int8(c))
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVBload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64CMPBload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVBload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPBload, psess.types.TypeFlags)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(x)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPBconst_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int8(x) == int8(y)) {
			break
		}
		v.reset(OpAMD64FlagEQ)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int8(x) < int8(y) && uint8(x) < uint8(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int8(x) < int8(y) && uint8(x) > uint8(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_UGT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int8(x) > int8(y) && uint8(x) < uint8(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int8(x) > int8(y) && uint8(x) > uint8(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_UGT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		m := v_0.AuxInt
		if !(0 <= int8(m) && int8(m) < int8(n)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64TESTB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64TESTBconst)
		v.AuxInt = int64(int8(c))
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64TESTB)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		l := v.Args[0]
		if l.Op != OpAMD64MOVBload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l.Uses == 1 && validValAndOff(c, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPBconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(c, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPBload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validValAndOff(int64(int8(c)), off)) {
			break
		}
		v.reset(OpAMD64CMPBconstload)
		v.AuxInt = makeValAndOff(int64(int8(c)), off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64CMPLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v0.AuxInt = c
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64CMPLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLload, psess.types.TypeFlags)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(x)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPLconst_0(v *Value) bool {

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int32(x) == int32(y)) {
			break
		}
		v.reset(OpAMD64FlagEQ)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int32(x) < int32(y) && uint32(x) < uint32(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int32(x) < int32(y) && uint32(x) > uint32(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_UGT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int32(x) > int32(y) && uint32(x) < uint32(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int32(x) > int32(y) && uint32(x) > uint32(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_UGT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		c := v_0.AuxInt
		if !(0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		m := v_0.AuxInt
		if !(0 <= int32(m) && int32(m) < int32(n)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64TESTL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64TESTLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64TESTL)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPLconst_10(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l.Uses == 1 && validValAndOff(c, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(c, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPLload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validValAndOff(c, off)) {
			break
		}
		v.reset(OpAMD64CMPLconstload)
		v.AuxInt = makeValAndOff(c, off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64CMPQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = c
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64CMPQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQload, psess.types.TypeFlags)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(x)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPQconst_0(v *Value) bool {

	for {
		if v.AuxInt != 32 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0.AuxInt != -16 {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0.AuxInt != 15 {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		if v.AuxInt != 32 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0.AuxInt != -8 {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0.AuxInt != 7 {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		x := v_0.AuxInt
		if !(x == y) {
			break
		}
		v.reset(OpAMD64FlagEQ)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		x := v_0.AuxInt
		if !(x < y && uint64(x) < uint64(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		x := v_0.AuxInt
		if !(x < y && uint64(x) > uint64(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_UGT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		x := v_0.AuxInt
		if !(x > y && uint64(x) < uint64(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		x := v_0.AuxInt
		if !(x > y && uint64(x) > uint64(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_UGT)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQZX {
			break
		}
		if !(0xFF < c) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVWQZX {
			break
		}
		if !(0xFFFF < c) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLQZX {
			break
		}
		if !(0xFFFFFFFF < c) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPQconst_10(v *Value) bool {
	b := v.Block
	_ = b

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		c := v_0.AuxInt
		if !(0 <= n && 0 < c && c <= 64 && (1<<uint64(64-c)) <= uint64(n)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQconst {
			break
		}
		m := v_0.AuxInt
		if !(0 <= m && m < n) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		m := v_0.AuxInt
		if !(0 <= m && m < n) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64TESTQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64TESTQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64TESTQ)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l.Uses == 1 && validValAndOff(c, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(c, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPQload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validValAndOff(c, off)) {
			break
		}
		v.reset(OpAMD64CMPQconstload)
		v.AuxInt = makeValAndOff(c, off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPW_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64CMPWconst)
		v.AuxInt = int64(int16(c))
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v0.AuxInt = int64(int16(c))
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVWload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64CMPWload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVWload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64InvertFlags)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPWload, psess.types.TypeFlags)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(x)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64CMPWconst_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int16(x) == int16(y)) {
			break
		}
		v.reset(OpAMD64FlagEQ)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int16(x) < int16(y) && uint16(x) < uint16(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int16(x) < int16(y) && uint16(x) > uint16(y)) {
			break
		}
		v.reset(OpAMD64FlagLT_UGT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int16(x) > int16(y) && uint16(x) < uint16(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_ULT)
		return true
	}

	for {
		y := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		x := v_0.AuxInt
		if !(int16(x) > int16(y) && uint16(x) > uint16(y)) {
			break
		}
		v.reset(OpAMD64FlagGT_UGT)
		return true
	}

	for {
		n := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		m := v_0.AuxInt
		if !(0 <= int16(m) && int16(m) < int16(n)) {
			break
		}
		v.reset(OpAMD64FlagLT_ULT)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v.reset(OpAMD64TESTW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64TESTWconst)
		v.AuxInt = int64(int16(c))
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64TESTW)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		l := v.Args[0]
		if l.Op != OpAMD64MOVWload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l.Uses == 1 && validValAndOff(c, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPWconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(c, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPWload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validValAndOff(int64(int16(c)), off)) {
			break
		}
		v.reset(OpAMD64CMPWconstload)
		v.AuxInt = makeValAndOff(int64(int16(c)), off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPXCHGLlock_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		old := v.Args[1]
		new_ := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64CMPXCHGLlock)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(old)
		v.AddArg(new_)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64CMPXCHGQlock_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		old := v.Args[1]
		new_ := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64CMPXCHGQlock)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(old)
		v.AddArg(new_)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAL_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAL)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAL1_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		y := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		d := v_1.AuxInt
		x := v_1.Args[0]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL2)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 2 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAL2_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+2*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL2)
		v.AuxInt = c + 2*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAL4_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+4*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL4)
		v.AuxInt = c + 4*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAL8_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+8*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAL8)
		v.AuxInt = c + 8*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAQ_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64LEAQ)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(x.Op != OpSB && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		x := v_0.Args[0]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64LEAQ)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ2 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAQ1_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		y := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		x := v_1.Args[0]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 2 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		y := v_0.Args[0]
		x := v.Args[1]
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		y := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		x := v_1.Args[0]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAQ2_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+2*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = c + 2*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAQ4_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+4*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = c + 4*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64LEAQ8_0(v *Value) bool {

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(c+d) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c + d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		y := v_1.Args[0]
		if !(is32Bit(c+8*d) && y.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = c + 8*d
		v.Aux = s
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		x := v_0.Args[0]
		y := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBQSX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVBload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(c&0x80 == 0) {
			break
		}
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & 0x7f
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBQSXload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVBstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBQSXload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBQZX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVBload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVBloadidx1 {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[2]
		ptr := x.Args[0]
		idx := x.Args[1]
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & 0xff
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVBstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		idx := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		p := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstore_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETL {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETLstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETLE {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETLEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETG {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETGstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETGE {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETGEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETEQ {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETNE {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETB {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETBE {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETBEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETA {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETAstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		y := v.Args[1]
		if y.Op != OpAMD64SETAE {
			break
		}
		x := y.Args[0]
		mem := v.Args[2]
		if !(y.Uses == 1) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstore_10(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVBQSX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVBQZX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validOff(off)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = makeValAndOff(int64(int8(c)), off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVBstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		w := v.Args[1]
		x0 := v.Args[2]
		if x0.Op != OpAMD64MOVBstore {
			break
		}
		if x0.AuxInt != i-1 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		x0_1 := x0.Args[1]
		if x0_1.Op != OpAMD64SHRWconst {
			break
		}
		if x0_1.AuxInt != 8 {
			break
		}
		if w != x0_1.Args[0] {
			break
		}
		mem := x0.Args[2]
		if !(x0.Uses == 1 && clobber(x0)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, w.Type)
		v0.AuxInt = 8
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		w := v.Args[1]
		x2 := v.Args[2]
		if x2.Op != OpAMD64MOVBstore {
			break
		}
		if x2.AuxInt != i-1 {
			break
		}
		if x2.Aux != s {
			break
		}
		_ = x2.Args[2]
		if p != x2.Args[0] {
			break
		}
		x2_1 := x2.Args[1]
		if x2_1.Op != OpAMD64SHRLconst {
			break
		}
		if x2_1.AuxInt != 8 {
			break
		}
		if w != x2_1.Args[0] {
			break
		}
		x1 := x2.Args[2]
		if x1.Op != OpAMD64MOVBstore {
			break
		}
		if x1.AuxInt != i-2 {
			break
		}
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		x1_1 := x1.Args[1]
		if x1_1.Op != OpAMD64SHRLconst {
			break
		}
		if x1_1.AuxInt != 16 {
			break
		}
		if w != x1_1.Args[0] {
			break
		}
		x0 := x1.Args[2]
		if x0.Op != OpAMD64MOVBstore {
			break
		}
		if x0.AuxInt != i-3 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		x0_1 := x0.Args[1]
		if x0_1.Op != OpAMD64SHRLconst {
			break
		}
		if x0_1.AuxInt != 24 {
			break
		}
		if w != x0_1.Args[0] {
			break
		}
		mem := x0.Args[2]
		if !(x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && clobber(x0) && clobber(x1) && clobber(x2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 3
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, w.Type)
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		w := v.Args[1]
		x6 := v.Args[2]
		if x6.Op != OpAMD64MOVBstore {
			break
		}
		if x6.AuxInt != i-1 {
			break
		}
		if x6.Aux != s {
			break
		}
		_ = x6.Args[2]
		if p != x6.Args[0] {
			break
		}
		x6_1 := x6.Args[1]
		if x6_1.Op != OpAMD64SHRQconst {
			break
		}
		if x6_1.AuxInt != 8 {
			break
		}
		if w != x6_1.Args[0] {
			break
		}
		x5 := x6.Args[2]
		if x5.Op != OpAMD64MOVBstore {
			break
		}
		if x5.AuxInt != i-2 {
			break
		}
		if x5.Aux != s {
			break
		}
		_ = x5.Args[2]
		if p != x5.Args[0] {
			break
		}
		x5_1 := x5.Args[1]
		if x5_1.Op != OpAMD64SHRQconst {
			break
		}
		if x5_1.AuxInt != 16 {
			break
		}
		if w != x5_1.Args[0] {
			break
		}
		x4 := x5.Args[2]
		if x4.Op != OpAMD64MOVBstore {
			break
		}
		if x4.AuxInt != i-3 {
			break
		}
		if x4.Aux != s {
			break
		}
		_ = x4.Args[2]
		if p != x4.Args[0] {
			break
		}
		x4_1 := x4.Args[1]
		if x4_1.Op != OpAMD64SHRQconst {
			break
		}
		if x4_1.AuxInt != 24 {
			break
		}
		if w != x4_1.Args[0] {
			break
		}
		x3 := x4.Args[2]
		if x3.Op != OpAMD64MOVBstore {
			break
		}
		if x3.AuxInt != i-4 {
			break
		}
		if x3.Aux != s {
			break
		}
		_ = x3.Args[2]
		if p != x3.Args[0] {
			break
		}
		x3_1 := x3.Args[1]
		if x3_1.Op != OpAMD64SHRQconst {
			break
		}
		if x3_1.AuxInt != 32 {
			break
		}
		if w != x3_1.Args[0] {
			break
		}
		x2 := x3.Args[2]
		if x2.Op != OpAMD64MOVBstore {
			break
		}
		if x2.AuxInt != i-5 {
			break
		}
		if x2.Aux != s {
			break
		}
		_ = x2.Args[2]
		if p != x2.Args[0] {
			break
		}
		x2_1 := x2.Args[1]
		if x2_1.Op != OpAMD64SHRQconst {
			break
		}
		if x2_1.AuxInt != 40 {
			break
		}
		if w != x2_1.Args[0] {
			break
		}
		x1 := x2.Args[2]
		if x1.Op != OpAMD64MOVBstore {
			break
		}
		if x1.AuxInt != i-6 {
			break
		}
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		x1_1 := x1.Args[1]
		if x1_1.Op != OpAMD64SHRQconst {
			break
		}
		if x1_1.AuxInt != 48 {
			break
		}
		if w != x1_1.Args[0] {
			break
		}
		x0 := x1.Args[2]
		if x0.Op != OpAMD64MOVBstore {
			break
		}
		if x0.AuxInt != i-7 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		x0_1 := x0.Args[1]
		if x0_1.Op != OpAMD64SHRQconst {
			break
		}
		if x0_1.AuxInt != 56 {
			break
		}
		if w != x0_1.Args[0] {
			break
		}
		mem := x0.Args[2]
		if !(x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i - 7
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, w.Type)
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstore_20(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRWconst {
			break
		}
		if v_1.AuxInt != 8 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstore {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		if v_1.AuxInt != 8 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstore {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		if v_1.AuxInt != 8 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstore {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		j := v_1.AuxInt
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstore {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		w0 := x.Args[1]
		if w0.Op != OpAMD64SHRLconst {
			break
		}
		if w0.AuxInt != j-8 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		j := v_1.AuxInt
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstore {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		w0 := x.Args[1]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-8 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		j := x1.AuxInt
		s2 := x1.Aux
		_ = x1.Args[1]
		p2 := x1.Args[0]
		mem := x1.Args[1]
		mem2 := v.Args[2]
		if mem2.Op != OpAMD64MOVBstore {
			break
		}
		if mem2.AuxInt != i-1 {
			break
		}
		if mem2.Aux != s {
			break
		}
		_ = mem2.Args[2]
		if p != mem2.Args[0] {
			break
		}
		x2 := mem2.Args[1]
		if x2.Op != OpAMD64MOVBload {
			break
		}
		if x2.AuxInt != j-1 {
			break
		}
		if x2.Aux != s2 {
			break
		}
		_ = x2.Args[1]
		if p2 != x2.Args[0] {
			break
		}
		if mem != x2.Args[1] {
			break
		}
		if mem != mem2.Args[2] {
			break
		}
		if !(x1.Uses == 1 && x2.Uses == 1 && mem2.Uses == 1 && clobber(x1) && clobber(x2) && clobber(mem2)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v0.AuxInt = j - 1
		v0.Aux = s2
		v0.AddArg(p2)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstoreconst_0(v *Value) bool {

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		v.reset(OpAMD64MOVBstoreconstidx1)
		v.AuxInt = x
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		p := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64MOVBstoreconst {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[1]
		if p != x.Args[0] {
			break
		}
		mem := x.Args[1]
		if !(x.Uses == 1 && ValAndOff(a).Off()+1 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = makeValAndOff(ValAndOff(a).Val()&0xff|ValAndOff(c).Val()<<8, ValAndOff(a).Off())
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstoreconstidx1_0(v *Value) bool {

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVBstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		i := v.Args[1]
		x := v.Args[2]
		if x.Op != OpAMD64MOVBstoreconstidx1 {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if i != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && ValAndOff(a).Off()+1 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx1)
		v.AuxInt = makeValAndOff(ValAndOff(a).Val()&0xff|ValAndOff(c).Val()<<8, ValAndOff(a).Off())
		v.Aux = s
		v.AddArg(p)
		v.AddArg(i)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstoreidx1_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVBstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		w := v.Args[2]
		x0 := v.Args[3]
		if x0.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x0.AuxInt != i-1 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[3]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		x0_2 := x0.Args[2]
		if x0_2.Op != OpAMD64SHRWconst {
			break
		}
		if x0_2.AuxInt != 8 {
			break
		}
		if w != x0_2.Args[0] {
			break
		}
		mem := x0.Args[3]
		if !(x0.Uses == 1 && clobber(x0)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, w.Type)
		v0.AuxInt = 8
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		w := v.Args[2]
		x2 := v.Args[3]
		if x2.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x2.AuxInt != i-1 {
			break
		}
		if x2.Aux != s {
			break
		}
		_ = x2.Args[3]
		if p != x2.Args[0] {
			break
		}
		if idx != x2.Args[1] {
			break
		}
		x2_2 := x2.Args[2]
		if x2_2.Op != OpAMD64SHRLconst {
			break
		}
		if x2_2.AuxInt != 8 {
			break
		}
		if w != x2_2.Args[0] {
			break
		}
		x1 := x2.Args[3]
		if x1.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x1.AuxInt != i-2 {
			break
		}
		if x1.Aux != s {
			break
		}
		_ = x1.Args[3]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		x1_2 := x1.Args[2]
		if x1_2.Op != OpAMD64SHRLconst {
			break
		}
		if x1_2.AuxInt != 16 {
			break
		}
		if w != x1_2.Args[0] {
			break
		}
		x0 := x1.Args[3]
		if x0.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x0.AuxInt != i-3 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[3]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		x0_2 := x0.Args[2]
		if x0_2.Op != OpAMD64SHRLconst {
			break
		}
		if x0_2.AuxInt != 24 {
			break
		}
		if w != x0_2.Args[0] {
			break
		}
		mem := x0.Args[3]
		if !(x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && clobber(x0) && clobber(x1) && clobber(x2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 3
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, w.Type)
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		w := v.Args[2]
		x6 := v.Args[3]
		if x6.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x6.AuxInt != i-1 {
			break
		}
		if x6.Aux != s {
			break
		}
		_ = x6.Args[3]
		if p != x6.Args[0] {
			break
		}
		if idx != x6.Args[1] {
			break
		}
		x6_2 := x6.Args[2]
		if x6_2.Op != OpAMD64SHRQconst {
			break
		}
		if x6_2.AuxInt != 8 {
			break
		}
		if w != x6_2.Args[0] {
			break
		}
		x5 := x6.Args[3]
		if x5.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x5.AuxInt != i-2 {
			break
		}
		if x5.Aux != s {
			break
		}
		_ = x5.Args[3]
		if p != x5.Args[0] {
			break
		}
		if idx != x5.Args[1] {
			break
		}
		x5_2 := x5.Args[2]
		if x5_2.Op != OpAMD64SHRQconst {
			break
		}
		if x5_2.AuxInt != 16 {
			break
		}
		if w != x5_2.Args[0] {
			break
		}
		x4 := x5.Args[3]
		if x4.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x4.AuxInt != i-3 {
			break
		}
		if x4.Aux != s {
			break
		}
		_ = x4.Args[3]
		if p != x4.Args[0] {
			break
		}
		if idx != x4.Args[1] {
			break
		}
		x4_2 := x4.Args[2]
		if x4_2.Op != OpAMD64SHRQconst {
			break
		}
		if x4_2.AuxInt != 24 {
			break
		}
		if w != x4_2.Args[0] {
			break
		}
		x3 := x4.Args[3]
		if x3.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x3.AuxInt != i-4 {
			break
		}
		if x3.Aux != s {
			break
		}
		_ = x3.Args[3]
		if p != x3.Args[0] {
			break
		}
		if idx != x3.Args[1] {
			break
		}
		x3_2 := x3.Args[2]
		if x3_2.Op != OpAMD64SHRQconst {
			break
		}
		if x3_2.AuxInt != 32 {
			break
		}
		if w != x3_2.Args[0] {
			break
		}
		x2 := x3.Args[3]
		if x2.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x2.AuxInt != i-5 {
			break
		}
		if x2.Aux != s {
			break
		}
		_ = x2.Args[3]
		if p != x2.Args[0] {
			break
		}
		if idx != x2.Args[1] {
			break
		}
		x2_2 := x2.Args[2]
		if x2_2.Op != OpAMD64SHRQconst {
			break
		}
		if x2_2.AuxInt != 40 {
			break
		}
		if w != x2_2.Args[0] {
			break
		}
		x1 := x2.Args[3]
		if x1.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x1.AuxInt != i-6 {
			break
		}
		if x1.Aux != s {
			break
		}
		_ = x1.Args[3]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		x1_2 := x1.Args[2]
		if x1_2.Op != OpAMD64SHRQconst {
			break
		}
		if x1_2.AuxInt != 48 {
			break
		}
		if w != x1_2.Args[0] {
			break
		}
		x0 := x1.Args[3]
		if x0.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x0.AuxInt != i-7 {
			break
		}
		if x0.Aux != s {
			break
		}
		_ = x0.Args[3]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		x0_2 := x0.Args[2]
		if x0_2.Op != OpAMD64SHRQconst {
			break
		}
		if x0_2.AuxInt != 56 {
			break
		}
		if w != x0_2.Args[0] {
			break
		}
		mem := x0.Args[3]
		if !(x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = i - 7
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, w.Type)
		v0.AddArg(w)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRWconst {
			break
		}
		if v_2.AuxInt != 8 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRLconst {
			break
		}
		if v_2.AuxInt != 8 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		if v_2.AuxInt != 8 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRLconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRLconst {
			break
		}
		if w0.AuxInt != j-8 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVBstoreidx1 {
			break
		}
		if x.AuxInt != i-1 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-8 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = i - 1
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVBstoreidx1_10(v *Value) bool {

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLQSX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(c&0x80000000 == 0) {
			break
		}
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & 0x7fffffff
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVLQSX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVWQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVWQSX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLQSXload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVLQSX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLQSXload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLQZX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if !(zeroUpper32Bits(x, 3)) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLloadidx1 {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[2]
		ptr := x.Args[0]
		idx := x.Args[1]
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLloadidx4 {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[2]
		ptr := x.Args[0]
		idx := x.Args[1]
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx4, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVLQZX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVWQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLatomicload_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVLatomicload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLatomicload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MOVLf2i_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpArg {
			break
		}
		u := v_0.Type
		off := v_0.AuxInt
		sym := v_0.Aux
		if !(t.Size(psess.types) == u.Size(psess.types)) {
			break
		}
		b = b.Func.Entry
		v0 := b.NewValue0(v.Pos, OpArg, t)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MOVLi2f_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpArg {
			break
		}
		u := v_0.Type
		off := v_0.AuxInt
		sym := v_0.Aux
		if !(t.Size(psess.types) == u.Size(psess.types)) {
			break
		}
		b = b.Func.Entry
		v0 := b.NewValue0(v.Pos, OpArg, t)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVLQZX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVSSstore {
			break
		}
		if v_1.AuxInt != off {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		val := v_1.Args[1]
		v.reset(OpAMD64MOVLf2i)
		v.AddArg(val)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLloadidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 2 {
			break
		}
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLloadidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLloadidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLloadidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		idx := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		p := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLloadidx4_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx4)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 4*d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx4)
		v.AuxInt = c + 4*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 4*c)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = i + 4*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLloadidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVLloadidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstore_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLQSX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLQZX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validOff(off)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = makeValAndOff(int64(int32(c)), off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		if v_1.AuxInt != 32 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVLstore {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstore_10(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		j := v_1.AuxInt
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVLstore {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		w0 := x.Args[1]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-32 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVLload {
			break
		}
		j := x1.AuxInt
		s2 := x1.Aux
		_ = x1.Args[1]
		p2 := x1.Args[0]
		mem := x1.Args[1]
		mem2 := v.Args[2]
		if mem2.Op != OpAMD64MOVLstore {
			break
		}
		if mem2.AuxInt != i-4 {
			break
		}
		if mem2.Aux != s {
			break
		}
		_ = mem2.Args[2]
		if p != mem2.Args[0] {
			break
		}
		x2 := mem2.Args[1]
		if x2.Op != OpAMD64MOVLload {
			break
		}
		if x2.AuxInt != j-4 {
			break
		}
		if x2.Aux != s2 {
			break
		}
		_ = x2.Args[1]
		if p2 != x2.Args[0] {
			break
		}
		if mem != x2.Args[1] {
			break
		}
		if mem != mem2.Args[2] {
			break
		}
		if !(x1.Uses == 1 && x2.Uses == 1 && mem2.Uses == 1 && clobber(x1) && clobber(x2) && clobber(mem2)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v0.AuxInt = j - 4
		v0.Aux = s2
		v0.AddArg(p2)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		a := v.Args[1]
		if a.Op != OpAMD64ADDLconst {
			break
		}
		c := a.AuxInt
		l := a.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		if l.AuxInt != off {
			break
		}
		if l.Aux != sym {
			break
		}
		_ = l.Args[1]
		ptr2 := l.Args[0]
		mem := l.Args[1]
		if mem != v.Args[2] {
			break
		}
		if !(isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c, off)) {
			break
		}
		v.reset(OpAMD64ADDLconstmodify)
		v.AuxInt = makeValAndOff(c, off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLf2i {
			break
		}
		val := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVSSstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreconst_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx4)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = x
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		p := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64MOVLstoreconst {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[1]
		if p != x.Args[0] {
			break
		}
		mem := x.Args[1]
		if !(x.Uses == 1 && ValAndOff(a).Off()+4 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = ValAndOff(a).Off()
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v0.AuxInt = ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreconstidx1_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstoreconstidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		i := v.Args[1]
		x := v.Args[2]
		if x.Op != OpAMD64MOVLstoreconstidx1 {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if i != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && ValAndOff(a).Off()+4 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = ValAndOff(a).Off()
		v.Aux = s
		v.AddArg(p)
		v.AddArg(i)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v0.AuxInt = ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreconstidx4_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx4)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(4 * c)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx4)
		v.AuxInt = ValAndOff(x).add(4 * c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		i := v.Args[1]
		x := v.Args[2]
		if x.Op != OpAMD64MOVLstoreconstidx4 {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if i != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && ValAndOff(a).Off()+4 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = ValAndOff(a).Off()
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, i.Type)
		v0.AuxInt = 2
		v0.AddArg(i)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v1.AuxInt = ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32
		v.AddArg(v1)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVLstoreidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVLstoreidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		if v_2.AuxInt != 32 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVLstoreidx1 {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVLstoreidx1 {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-32 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreidx4_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx4)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 4*d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx4)
		v.AuxInt = c + 4*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		if v_2.AuxInt != 32 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVLstoreidx4 {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type)
		v0.AuxInt = 2
		v0.AddArg(idx)
		v.AddArg(v0)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVLstoreidx4 {
			break
		}
		if x.AuxInt != i-4 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-32 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = i - 4
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type)
		v0.AuxInt = 2
		v0.AddArg(idx)
		v.AddArg(v0)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 4*c)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i + 4*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVLstoreidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVOload_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVOload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVOload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVOstore_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQatomicload_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVQatomicload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQatomicload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MOVQf2i_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpArg {
			break
		}
		u := v_0.Type
		off := v_0.AuxInt
		sym := v_0.Aux
		if !(t.Size(psess.types) == u.Size(psess.types)) {
			break
		}
		b = b.Func.Entry
		v0 := b.NewValue0(v.Pos, OpArg, t)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MOVQi2f_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpArg {
			break
		}
		u := v_0.Type
		off := v_0.AuxInt
		sym := v_0.Aux
		if !(t.Size(psess.types) == u.Size(psess.types)) {
			break
		}
		b = b.Func.Entry
		v0 := b.NewValue0(v.Pos, OpArg, t)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVSDstore {
			break
		}
		if v_1.AuxInt != off {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		val := v_1.Args[1]
		v.reset(OpAMD64MOVQf2i)
		v.AddArg(val)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVQloadidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 3 {
			break
		}
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVQloadidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		idx := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		p := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQloadidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVQloadidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQstore_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validValAndOff(c, off)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = makeValAndOff(c, off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		a := v.Args[1]
		if a.Op != OpAMD64ADDQconst {
			break
		}
		c := a.AuxInt
		l := a.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		if l.AuxInt != off {
			break
		}
		if l.Aux != sym {
			break
		}
		_ = l.Args[1]
		ptr2 := l.Args[0]
		mem := l.Args[1]
		if mem != v.Args[2] {
			break
		}
		if !(isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c, off)) {
			break
		}
		v.reset(OpAMD64ADDQconstmodify)
		v.AuxInt = makeValAndOff(c, off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQf2i {
			break
		}
		val := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVSDstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MOVQstoreconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx8)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		v.reset(OpAMD64MOVQstoreconstidx1)
		v.AuxInt = x
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		p := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64MOVQstoreconst {
			break
		}
		c2 := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[1]
		if p != x.Args[0] {
			break
		}
		mem := x.Args[1]
		if !(config.useSSE && x.Uses == 1 && ValAndOff(c2).Off()+8 == ValAndOff(c).Off() && ValAndOff(c).Val() == 0 && ValAndOff(c2).Val() == 0 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v.AuxInt = ValAndOff(c2).Off()
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQstoreconstidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVQstoreconstidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQstoreconstidx8_0(v *Value) bool {

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx8)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(8 * c)) {
			break
		}
		v.reset(OpAMD64MOVQstoreconstidx8)
		v.AuxInt = ValAndOff(x).add(8 * c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQstoreidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVQstoreidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVQstoreidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVQstoreidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDload_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVSDload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQstore {
			break
		}
		if v_1.AuxInt != off {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		val := v_1.Args[1]
		v.reset(OpAMD64MOVQi2f)
		v.AddArg(val)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVSDloadidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVSDload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDloadidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVSDloadidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVSDload)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDstore_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVSDstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ8 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx8)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQi2f {
			break
		}
		val := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDstoreidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 3 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVSDstoreidx8)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVSDstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSDstoreidx8_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx8)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 8*d)) {
			break
		}
		v.reset(OpAMD64MOVSDstoreidx8)
		v.AuxInt = c + 8*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 8*c)) {
			break
		}
		v.reset(OpAMD64MOVSDstore)
		v.AuxInt = i + 8*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSload_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVSSload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLstore {
			break
		}
		if v_1.AuxInt != off {
			break
		}
		if v_1.Aux != sym {
			break
		}
		_ = v_1.Args[2]
		if ptr != v_1.Args[0] {
			break
		}
		val := v_1.Args[1]
		v.reset(OpAMD64MOVLi2f)
		v.AddArg(val)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVSSloadidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVSSload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSloadidx4_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx4)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 4*d)) {
			break
		}
		v.reset(OpAMD64MOVSSloadidx4)
		v.AuxInt = c + 4*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 4*c)) {
			break
		}
		v.reset(OpAMD64MOVSSload)
		v.AuxInt = i + 4*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSstore_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVSSstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ4 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx4)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLi2f {
			break
		}
		val := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSstoreidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 2 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVSSstoreidx4)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVSSstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVSSstoreidx4_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx4)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 4*d)) {
			break
		}
		v.reset(OpAMD64MOVSSstoreidx4)
		v.AuxInt = c + 4*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 4*c)) {
			break
		}
		v.reset(OpAMD64MOVSSstore)
		v.AuxInt = i + 4*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWQSX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(c&0x8000 == 0) {
			break
		}
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & 0x7fff
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVWQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVWQSX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQSX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWQSXload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVWstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVWQSX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWQSXload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWQZX_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVLload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVQload {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[1]
		ptr := x.Args[0]
		mem := x.Args[1]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWloadidx1 {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[2]
		ptr := x.Args[0]
		idx := x.Args[1]
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		x := v.Args[0]
		if x.Op != OpAMD64MOVWloadidx2 {
			break
		}
		off := x.AuxInt
		sym := x.Aux
		_ = x.Args[2]
		ptr := x.Args[0]
		idx := x.Args[1]
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		b = x.Block
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx2, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = off
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ANDLconst)
		v.AuxInt = c & 0xffff
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVWQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVBQZX {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWload_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVWstore {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		_ = v_1.Args[2]
		ptr2 := v_1.Args[0]
		x := v_1.Args[1]
		if !(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)) {
			break
		}
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ2 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx2)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWloadidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWloadidx2)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWloadidx2)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		idx := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		idx := v_0.Args[0]
		ptr := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		p := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWloadidx2_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx2)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(c + 2*d)) {
			break
		}
		v.reset(OpAMD64MOVWloadidx2)
		v.AuxInt = c + 2*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(is32Bit(i + 2*c)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AuxInt = i + 2*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstore_0(v *Value) bool {

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVWQSX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVWQZX {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		mem := v.Args[2]
		if !(validOff(off)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = makeValAndOff(int64(int16(c)), off)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ2 {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx2)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		val := v.Args[1]
		mem := v.Args[2]
		if !(ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		if v_1.AuxInt != 16 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstore {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		if v_1.AuxInt != 16 {
			break
		}
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstore {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if w != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstore_10(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		j := v_1.AuxInt
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstore {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		w0 := x.Args[1]
		if w0.Op != OpAMD64SHRLconst {
			break
		}
		if w0.AuxInt != j-16 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		j := v_1.AuxInt
		w := v_1.Args[0]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstore {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		w0 := x.Args[1]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-16 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		j := x1.AuxInt
		s2 := x1.Aux
		_ = x1.Args[1]
		p2 := x1.Args[0]
		mem := x1.Args[1]
		mem2 := v.Args[2]
		if mem2.Op != OpAMD64MOVWstore {
			break
		}
		if mem2.AuxInt != i-2 {
			break
		}
		if mem2.Aux != s {
			break
		}
		_ = mem2.Args[2]
		if p != mem2.Args[0] {
			break
		}
		x2 := mem2.Args[1]
		if x2.Op != OpAMD64MOVWload {
			break
		}
		if x2.AuxInt != j-2 {
			break
		}
		if x2.Aux != s2 {
			break
		}
		_ = x2.Args[1]
		if p2 != x2.Args[0] {
			break
		}
		if mem != x2.Args[1] {
			break
		}
		if mem != mem2.Args[2] {
			break
		}
		if !(x1.Uses == 1 && x2.Uses == 1 && mem2.Uses == 1 && clobber(x1) && clobber(x2) && clobber(mem2)) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v0.AuxInt = j - 2
		v0.Aux = s2
		v0.AddArg(p2)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(canMergeSym(sym1, sym2) && is32Bit(off1+off2)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off2 := v_0.AuxInt
		ptr := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstoreconst_0(v *Value) bool {

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ1 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ2 {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx2)
		v.AuxInt = ValAndOff(x).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQ {
			break
		}
		_ = v_0.Args[1]
		ptr := v_0.Args[0]
		idx := v_0.Args[1]
		mem := v.Args[1]
		v.reset(OpAMD64MOVWstoreconstidx1)
		v.AuxInt = x
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		p := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64MOVWstoreconst {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[1]
		if p != x.Args[0] {
			break
		}
		mem := x.Args[1]
		if !(x.Uses == 1 && ValAndOff(a).Off()+2 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = makeValAndOff(ValAndOff(a).Val()&0xffff|ValAndOff(c).Val()<<16, ValAndOff(a).Off())
		v.Aux = s
		v.AddArg(p)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAL {
			break
		}
		off := v_0.AuxInt
		sym2 := v_0.Aux
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		sc := v.AuxInt
		s := v.Aux
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDLconst {
			break
		}
		off := v_0.AuxInt
		ptr := v_0.Args[0]
		mem := v.Args[1]
		if !(ValAndOff(sc).canAdd(off)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = ValAndOff(sc).add(off)
		v.Aux = s
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstoreconstidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		idx := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWstoreconstidx2)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx1)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		i := v.Args[1]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstoreconstidx1 {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if i != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && ValAndOff(a).Off()+2 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = makeValAndOff(ValAndOff(a).Val()&0xffff|ValAndOff(c).Val()<<16, ValAndOff(a).Off())
		v.Aux = s
		v.AddArg(p)
		v.AddArg(i)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstoreconstidx2_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(c)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx2)
		v.AuxInt = ValAndOff(x).add(c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		x := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		idx := v_1.Args[0]
		mem := v.Args[2]
		if !(ValAndOff(x).canAdd(2 * c)) {
			break
		}
		v.reset(OpAMD64MOVWstoreconstidx2)
		v.AuxInt = ValAndOff(x).add(2 * c)
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		s := v.Aux
		_ = v.Args[2]
		p := v.Args[0]
		i := v.Args[1]
		x := v.Args[2]
		if x.Op != OpAMD64MOVWstoreconstidx2 {
			break
		}
		a := x.AuxInt
		if x.Aux != s {
			break
		}
		_ = x.Args[2]
		if p != x.Args[0] {
			break
		}
		if i != x.Args[1] {
			break
		}
		mem := x.Args[2]
		if !(x.Uses == 1 && ValAndOff(a).Off()+2 == ValAndOff(c).Off() && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreconstidx1)
		v.AuxInt = makeValAndOff(ValAndOff(a).Val()&0xffff|ValAndOff(c).Val()<<16, ValAndOff(a).Off())
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, i.Type)
		v0.AuxInt = 1
		v0.AddArg(i)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstoreidx1_0(v *Value) bool {

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64MOVWstoreidx2)
		v.AuxInt = c
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx1)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRLconst {
			break
		}
		if v_2.AuxInt != 16 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx1 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		if v_2.AuxInt != 16 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx1 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRLconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx1 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRLconst {
			break
		}
		if w0.AuxInt != j-16 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx1 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-16 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v.AddArg(idx)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + c)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i + c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MOVWstoreidx2_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		d := v_0.AuxInt
		ptr := v_0.Args[0]
		idx := v.Args[1]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + d)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx2)
		v.AuxInt = c + d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		c := v.AuxInt
		sym := v.Aux
		_ = v.Args[3]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		d := v_1.AuxInt
		idx := v_1.Args[0]
		val := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(c + 2*d)) {
			break
		}
		v.reset(OpAMD64MOVWstoreidx2)
		v.AuxInt = c + 2*d
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(idx)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRLconst {
			break
		}
		if v_2.AuxInt != 16 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx2 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type)
		v0.AuxInt = 1
		v0.AddArg(idx)
		v.AddArg(v0)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		if v_2.AuxInt != 16 {
			break
		}
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx2 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		if w != x.Args[2] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type)
		v0.AuxInt = 1
		v0.AddArg(idx)
		v.AddArg(v0)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		idx := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SHRQconst {
			break
		}
		j := v_2.AuxInt
		w := v_2.Args[0]
		x := v.Args[3]
		if x.Op != OpAMD64MOVWstoreidx2 {
			break
		}
		if x.AuxInt != i-2 {
			break
		}
		if x.Aux != s {
			break
		}
		_ = x.Args[3]
		if p != x.Args[0] {
			break
		}
		if idx != x.Args[1] {
			break
		}
		w0 := x.Args[2]
		if w0.Op != OpAMD64SHRQconst {
			break
		}
		if w0.AuxInt != j-16 {
			break
		}
		if w != w0.Args[0] {
			break
		}
		mem := x.Args[3]
		if !(x.Uses == 1 && clobber(x)) {
			break
		}
		v.reset(OpAMD64MOVLstoreidx1)
		v.AuxInt = i - 2
		v.Aux = s
		v.AddArg(p)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type)
		v0.AuxInt = 1
		v0.AddArg(idx)
		v.AddArg(v0)
		v.AddArg(w0)
		v.AddArg(mem)
		return true
	}

	for {
		i := v.AuxInt
		s := v.Aux
		_ = v.Args[3]
		p := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		w := v.Args[2]
		mem := v.Args[3]
		if !(is32Bit(i + 2*c)) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = i + 2*c
		v.Aux = s
		v.AddArg(p)
		v.AddArg(w)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULL_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64MULLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64MULLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULLconst_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MULLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64MULLconst)
		v.AuxInt = int64(int32(c * d))
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != -9 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -5 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -3 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 3 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 5 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 7 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULLconst_10(v *Value) bool {
	b := v.Block
	_ = b

	for {
		if v.AuxInt != 9 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 11 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 13 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 19 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 21 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 25 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 27 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 37 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 41 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 45 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULLconst_20(v *Value) bool {
	b := v.Block
	_ = b

	for {
		if v.AuxInt != 73 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 81 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAL8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c+1) && c >= 15) {
			break
		}
		v.reset(OpAMD64SUBL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v0.AuxInt = log2(c + 1)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-1) && c >= 17) {
			break
		}
		v.reset(OpAMD64LEAL1)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v0.AuxInt = log2(c - 1)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-2) && c >= 34) {
			break
		}
		v.reset(OpAMD64LEAL2)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v0.AuxInt = log2(c - 2)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-4) && c >= 68) {
			break
		}
		v.reset(OpAMD64LEAL4)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v0.AuxInt = log2(c - 4)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-8) && c >= 136) {
			break
		}
		v.reset(OpAMD64LEAL8)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v0.AuxInt = log2(c - 8)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%3 == 0 && isPowerOfTwo(c/3)) {
			break
		}
		v.reset(OpAMD64SHLLconst)
		v.AuxInt = log2(c / 3)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%5 == 0 && isPowerOfTwo(c/5)) {
			break
		}
		v.reset(OpAMD64SHLLconst)
		v.AuxInt = log2(c / 5)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%9 == 0 && isPowerOfTwo(c/9)) {
			break
		}
		v.reset(OpAMD64SHLLconst)
		v.AuxInt = log2(c / 9)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULLconst_30(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = int64(int32(c * d))
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULQ_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64MULQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64MULQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULQconst_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MULQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(is32Bit(c * d)) {
			break
		}
		v.reset(OpAMD64MULQconst)
		v.AuxInt = c * d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != -9 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGQ)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -5 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGQ)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -3 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGQ)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64NEGQ)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 3 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 5 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 7 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULQconst_10(v *Value) bool {
	b := v.Block
	_ = b

	for {
		if v.AuxInt != 9 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 11 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 13 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 19 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ2)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 21 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 25 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 27 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 37 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ4)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 41 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 45 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULQconst_20(v *Value) bool {
	b := v.Block
	_ = b

	for {
		if v.AuxInt != 73 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 81 {
			break
		}
		x := v.Args[0]
		v.reset(OpAMD64LEAQ8)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v1.AddArg(x)
		v1.AddArg(x)
		v.AddArg(v1)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c+1) && c >= 15) {
			break
		}
		v.reset(OpAMD64SUBQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v0.AuxInt = log2(c + 1)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-1) && c >= 17) {
			break
		}
		v.reset(OpAMD64LEAQ1)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v0.AuxInt = log2(c - 1)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-2) && c >= 34) {
			break
		}
		v.reset(OpAMD64LEAQ2)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v0.AuxInt = log2(c - 2)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-4) && c >= 68) {
			break
		}
		v.reset(OpAMD64LEAQ4)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v0.AuxInt = log2(c - 4)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isPowerOfTwo(c-8) && c >= 136) {
			break
		}
		v.reset(OpAMD64LEAQ8)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v0.AuxInt = log2(c - 8)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%3 == 0 && isPowerOfTwo(c/3)) {
			break
		}
		v.reset(OpAMD64SHLQconst)
		v.AuxInt = log2(c / 3)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%5 == 0 && isPowerOfTwo(c/5)) {
			break
		}
		v.reset(OpAMD64SHLQconst)
		v.AuxInt = log2(c / 5)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c%9 == 0 && isPowerOfTwo(c/9)) {
			break
		}
		v.reset(OpAMD64SHLQconst)
		v.AuxInt = log2(c / 9)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type)
		v0.AddArg(x)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULQconst_30(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = c * d
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MULSD_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSDload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64MULSDload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVSDload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64MULSDload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULSDload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MULSDload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MULSDload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVQstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64MULSD)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64MULSS_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSSload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64MULSSload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVSSload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64MULSSload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64MULSSload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64MULSSload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64MULSSload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVLstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64MULSS)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64NEGL_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGL {
			break
		}
		x := v_0.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = int64(int32(-c))
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64NEGQ_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64NEGQ {
			break
		}
		x := v_0.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = -c
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_0.AuxInt
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64NEGQ {
			break
		}
		x := v_0_0.Args[0]
		if !(c != -(1 << 31)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = -c
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64NOTL_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = ^c
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64NOTQ_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = ^c
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTSL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_0.AuxInt != 1 {
			break
		}
		y := v_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTSL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ORLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64ORLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRWconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRWconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_10(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRBconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRBconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 32 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -32 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 32 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -32 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 32 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -32 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 32 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -32 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 31 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 32 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -32 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 32 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -32 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 32 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -32 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 32 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -32 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 31 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_20(v *Value) bool {

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 32 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -32 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 32 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -32 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 32 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -32 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 32 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -32 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 31 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 32 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -32 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 32 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -32 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 32 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -32 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 31 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 32 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -32 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 31 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_1_0 := v_1_0_1.Args[0]
		if v_1_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_1_0.AuxInt != -16 {
			break
		}
		v_1_0_1_0_0 := v_1_0_1_0.Args[0]
		if v_1_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_0_1_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 16 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -16 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 16 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -16 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_1_0 := v_1_1_1.Args[0]
		if v_1_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_1_0.AuxInt != -16 {
			break
		}
		v_1_1_1_0_0 := v_1_1_1_0.Args[0]
		if v_1_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_30(v *Value) bool {

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_1_0 := v_0_0_1.Args[0]
		if v_0_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_1_0.AuxInt != -16 {
			break
		}
		v_0_0_1_0_0 := v_0_0_1_0.Args[0]
		if v_0_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_1_0_0.AuxInt != 15 {
			break
		}
		y := v_0_0_1_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 16 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -16 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 16 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -16 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 15 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_1_0 := v_0_1_1.Args[0]
		if v_0_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_1_0.AuxInt != -16 {
			break
		}
		v_0_1_1_0_0 := v_0_1_1_0.Args[0]
		if v_0_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_0_1_1_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		v_1_0_1_0 := v_1_0_1.Args[0]
		if v_1_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_1_0.AuxInt != -16 {
			break
		}
		v_1_0_1_0_0 := v_1_0_1_0.Args[0]
		if v_1_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_0_1_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 16 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -16 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 16 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -16 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		v_1_1_1_0 := v_1_1_1.Args[0]
		if v_1_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_1_0.AuxInt != -16 {
			break
		}
		v_1_1_1_0_0 := v_1_1_1_0.Args[0]
		if v_1_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		v_0_0_1_0 := v_0_0_1.Args[0]
		if v_0_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_1_0.AuxInt != -16 {
			break
		}
		v_0_0_1_0_0 := v_0_0_1_0.Args[0]
		if v_0_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_1_0_0.AuxInt != 15 {
			break
		}
		y := v_0_0_1_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 16 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -16 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 15 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 16 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -16 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 15 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		v_0_1_1_0 := v_0_1_1.Args[0]
		if v_0_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_1_0.AuxInt != -16 {
			break
		}
		v_0_1_1_0_0 := v_0_1_1_0.Args[0]
		if v_0_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_0_1_1_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0.AuxInt != -16 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0.AuxInt != -16 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0.AuxInt != 15 {
			break
		}
		y := v_0_1_0_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRW {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 15 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0.AuxInt != -16 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0.AuxInt != 15 {
			break
		}
		if y != v_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0.AuxInt != -16 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0.AuxInt != 15 {
			break
		}
		y := v_0_1_0_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRW {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 15 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_40(v *Value) bool {

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_1_0 := v_1_0_1.Args[0]
		if v_1_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_1_0.AuxInt != -8 {
			break
		}
		v_1_0_1_0_0 := v_1_0_1_0.Args[0]
		if v_1_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_0_1_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 8 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -8 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 8 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -8 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_1_0 := v_1_1_1.Args[0]
		if v_1_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_1_0.AuxInt != -8 {
			break
		}
		v_1_1_1_0_0 := v_1_1_1_0.Args[0]
		if v_1_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_1_0 := v_0_0_1.Args[0]
		if v_0_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_1_0.AuxInt != -8 {
			break
		}
		v_0_0_1_0_0 := v_0_0_1_0.Args[0]
		if v_0_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_1_0_0.AuxInt != 7 {
			break
		}
		y := v_0_0_1_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 8 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -8 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 8 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -8 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 7 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_1_0 := v_0_1_1.Args[0]
		if v_0_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_1_0.AuxInt != -8 {
			break
		}
		v_0_1_1_0_0 := v_0_1_1_0.Args[0]
		if v_0_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_0_1_1_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		v_1_0_1_0 := v_1_0_1.Args[0]
		if v_1_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_1_0.AuxInt != -8 {
			break
		}
		v_1_0_1_0_0 := v_1_0_1_0.Args[0]
		if v_1_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_0_1_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 8 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -8 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 8 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -8 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		v_1_1_1_0 := v_1_1_1.Args[0]
		if v_1_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_1_0.AuxInt != -8 {
			break
		}
		v_1_1_1_0_0 := v_1_1_1_0.Args[0]
		if v_1_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		v_0_0_1_0 := v_0_0_1.Args[0]
		if v_0_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_1_0.AuxInt != -8 {
			break
		}
		v_0_0_1_0_0 := v_0_0_1_0.Args[0]
		if v_0_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_1_0_0.AuxInt != 7 {
			break
		}
		y := v_0_0_1_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 8 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -8 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 7 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBLcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 8 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -8 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 7 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		v_0_1_1_0 := v_0_1_1.Args[0]
		if v_0_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_1_0.AuxInt != -8 {
			break
		}
		v_0_1_1_0_0 := v_0_1_1_0.Args[0]
		if v_0_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_0_1_1_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0.AuxInt != -8 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0.AuxInt != -8 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0.AuxInt != 7 {
			break
		}
		y := v_0_1_0_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_50(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRB {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1.AuxInt != 7 {
			break
		}
		y := v_0_1.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0.AuxInt != -8 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0.AuxInt != 7 {
			break
		}
		if y != v_1_1_0_0.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0.AuxInt != -8 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0.AuxInt != 7 {
			break
		}
		y := v_0_1_0_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRB {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1.AuxInt != 7 {
			break
		}
		if y != v_1_1.Args[0] {
			break
		}
		if !(v.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_60(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_70(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_80(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_90(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_100(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_110(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLLconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORL_120(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORL_130(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORL {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLLconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLLconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ORLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ORLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORLconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(int32(c) == 0) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		if !(int32(c) == -1) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = -1
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = c | d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORLload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ORLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ORLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSSstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ORL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTSQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_0.AuxInt != 1 {
			break
		}
		y := v_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTSQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ORQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64ORQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 64 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -64 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 64 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -64 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_10(v *Value) bool {

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 64 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -64 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 64 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -64 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 63 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 64 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -64 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 64 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -64 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 64 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -64 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 64 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -64 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 63 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_1_0.AuxInt != 64 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -64 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_1_0_0.AuxInt != 64 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -64 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_1_0.AuxInt != 64 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -64 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0_0_0.AuxInt != 64 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGQ {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDQconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -64 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDQconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 63 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGQ {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_20(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_0.Args[1]
		if x != v_1_0.Args[0] {
			break
		}
		v_1_0_1 := v_1_0.Args[1]
		if v_1_0_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_0_1.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_1_0.AuxInt != 64 {
			break
		}
		v_1_1_0_0 := v_1_1_0.Args[0]
		if v_1_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_1_0_0_0 := v_1_1_0_0.Args[0]
		if v_1_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_1_0_0_0.AuxInt != -64 {
			break
		}
		v_1_1_0_0_0_0 := v_1_1_0_0_0.Args[0]
		if v_1_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_1_0_0_0_0.Args[0] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		y := v_0.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_1_0_0.AuxInt != 64 {
			break
		}
		v_1_0_0_0 := v_1_0_0.Args[0]
		if v_1_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_1_0_0_0_0 := v_1_0_0_0.Args[0]
		if v_1_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_1_0_0_0_0.AuxInt != -64 {
			break
		}
		v_1_0_0_0_0_0 := v_1_0_0_0_0.Args[0]
		if v_1_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_1_0_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_1_0_0_0_0_0.Args[0] {
			break
		}
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_1.Args[1]
		if x != v_1_1.Args[0] {
			break
		}
		v_1_1_1 := v_1_1.Args[1]
		if v_1_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_1_1_1.Args[0] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_0.Args[1]
		x := v_0_0.Args[0]
		v_0_0_1 := v_0_0.Args[1]
		if v_0_0_1.Op != OpAMD64NEGL {
			break
		}
		y := v_0_0_1.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_1_0.AuxInt != 64 {
			break
		}
		v_0_1_0_0 := v_0_1_0.Args[0]
		if v_0_1_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_1_0_0_0 := v_0_1_0_0.Args[0]
		if v_0_1_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_1_0_0_0.AuxInt != -64 {
			break
		}
		v_0_1_0_0_0_0 := v_0_1_0_0_0.Args[0]
		if v_0_1_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_1_0_0_0_0.AuxInt != 63 {
			break
		}
		if y != v_0_1_0_0_0_0.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ANDQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SBBQcarrymask {
			break
		}
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0_0_0.AuxInt != 64 {
			break
		}
		v_0_0_0_0 := v_0_0_0.Args[0]
		if v_0_0_0_0.Op != OpAMD64NEGL {
			break
		}
		v_0_0_0_0_0 := v_0_0_0_0.Args[0]
		if v_0_0_0_0_0.Op != OpAMD64ADDLconst {
			break
		}
		if v_0_0_0_0_0.AuxInt != -64 {
			break
		}
		v_0_0_0_0_0_0 := v_0_0_0_0_0.Args[0]
		if v_0_0_0_0_0_0.Op != OpAMD64ANDLconst {
			break
		}
		if v_0_0_0_0_0_0.AuxInt != 63 {
			break
		}
		y := v_0_0_0_0_0_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_1.Args[1]
		x := v_0_1.Args[0]
		v_0_1_1 := v_0_1.Args[1]
		if v_0_1_1.Op != OpAMD64NEGL {
			break
		}
		if y != v_0_1_1.Args[0] {
			break
		}
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQ {
			break
		}
		_ = v_1.Args[1]
		if x != v_1.Args[0] {
			break
		}
		if y != v_1.Args[1] {
			break
		}
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVLload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_30(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVLload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_40(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_50(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		x0 := v.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_60(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		x1 := sh.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		x0 := v.Args[1]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = i0
		v0.Aux = s
		v0.AddArg(p)
		v0.AddArg(idx)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_70(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_80(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s1 := v.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_90(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s0 := or.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		y := or.Args[1]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s0 := or.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		s1 := v.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j0
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v2.AuxInt = i0
		v2.Aux = s
		v2.AddArg(p)
		v2.AddArg(idx)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_100(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		r1 := v.Args[1]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[1]
		p := x0.Args[0]
		mem := x0.Args[1]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[1]
		if p != x1.Args[0] {
			break
		}
		if mem != x1.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWload {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[1]
		p := x1.Args[0]
		mem := x1.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWload {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[1]
		if p != x0.Args[0] {
			break
		}
		if mem != x0.Args[1] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_110(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x1 := v.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 8 {
			break
		}
		x0 := sh.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		x1 := v.Args[1]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = 8
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_120(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 16 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		r1 := v.Args[0]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		sh := v.Args[1]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_130(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		sh := v.Args[0]
		if sh.Op != OpAMD64SHLQconst {
			break
		}
		if sh.AuxInt != 32 {
			break
		}
		r0 := sh.Args[0]
		if r0.Op != OpAMD64BSWAPL {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		r1 := v.Args[1]
		if r1.Op != OpAMD64BSWAPL {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVLloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64)
		v1.AuxInt = i0
		v1.Aux = s
		v1.AddArg(p)
		v1.AddArg(idx)
		v1.AddArg(mem)
		v0.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_140(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		x1 := s1.Args[0]
		if x1.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		x0 := s0.Args[0]
		if x0.Op != OpAMD64MOVBloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16)
		v2.AuxInt = 8
		v3 := b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQ_150(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		y := or.Args[1]
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if p != x1.Args[0] {
			break
		}
		if idx != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		p := x0.Args[0]
		idx := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		s0 := v.Args[0]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		s := x0.Aux
		_ = x0.Args[2]
		idx := x0.Args[0]
		p := x0.Args[1]
		mem := x0.Args[2]
		or := v.Args[1]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		if x1.Aux != s {
			break
		}
		_ = x1.Args[2]
		if idx != x1.Args[0] {
			break
		}
		if p != x1.Args[1] {
			break
		}
		if mem != x1.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64ORQ_160(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if p != x0.Args[0] {
			break
		}
		if idx != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		s1 := or.Args[0]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		y := or.Args[1]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		p := x1.Args[0]
		idx := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		or := v.Args[0]
		if or.Op != OpAMD64ORQ {
			break
		}
		_ = or.Args[1]
		y := or.Args[0]
		s1 := or.Args[1]
		if s1.Op != OpAMD64SHLQconst {
			break
		}
		j1 := s1.AuxInt
		r1 := s1.Args[0]
		if r1.Op != OpAMD64ROLWconst {
			break
		}
		if r1.AuxInt != 8 {
			break
		}
		x1 := r1.Args[0]
		if x1.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i1 := x1.AuxInt
		s := x1.Aux
		_ = x1.Args[2]
		idx := x1.Args[0]
		p := x1.Args[1]
		mem := x1.Args[2]
		s0 := v.Args[1]
		if s0.Op != OpAMD64SHLQconst {
			break
		}
		j0 := s0.AuxInt
		r0 := s0.Args[0]
		if r0.Op != OpAMD64ROLWconst {
			break
		}
		if r0.AuxInt != 8 {
			break
		}
		x0 := r0.Args[0]
		if x0.Op != OpAMD64MOVWloadidx1 {
			break
		}
		i0 := x0.AuxInt
		if x0.Aux != s {
			break
		}
		_ = x0.Args[2]
		if idx != x0.Args[0] {
			break
		}
		if p != x0.Args[1] {
			break
		}
		if mem != x0.Args[2] {
			break
		}
		if !(i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)) {
			break
		}
		b = mergePoint(b, x0, x1)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, v.Type)
		v.reset(OpCopy)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type)
		v1.AuxInt = j1
		v2 := b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32)
		v3.AuxInt = i0
		v3.Aux = s
		v3.AddArg(p)
		v3.AddArg(idx)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v0.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ORQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64ORQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTSQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != -1 {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = -1
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = c | d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ORQload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64ORQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64ORQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSDstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64ORQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c & 7
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c & 7
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLBconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ROLBconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = (c + d) & 7
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLL_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ROLLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = (c + d) & 31
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLQ_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLQconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ROLQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = (c + d) & 63
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLW_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64RORW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c & 15
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c & 15
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64ROLWconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ROLWconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = (c + d) & 15
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64RORB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = (-c) & 7
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = (-c) & 7
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64RORL_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = (-c) & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = (-c) & 31
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64RORQ_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = (-c) & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = (-c) & 63
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64RORW_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		y := v_1.Args[0]
		v.reset(OpAMD64ROLW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = (-c) & 15
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = (-c) & 15
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARBconst)
		v.AuxInt = min(c&31, 7)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARBconst)
		v.AuxInt = min(c&31, 7)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARBconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = int64(int8(d)) >> uint64(c)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARLconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = int64(int32(d)) >> uint64(c)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARQconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = d >> uint64(c)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARW_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARWconst)
		v.AuxInt = min(c&31, 15)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SARWconst)
		v.AuxInt = min(c&31, 15)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SARWconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = int64(int16(d)) >> uint64(c)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SBBLcarrymask_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = -1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = -1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SBBQcarrymask_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = -1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = -1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETA_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETB)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETAE_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETBE)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETAEstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETBEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETAstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETAstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETAstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETB_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETA)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETBE_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETAE)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETBEstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETBEstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETBEstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETBstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETAstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQ_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		x := v_0_0.Args[1]
		y := v_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_1.Args[1]
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_1_0.AuxInt != 1 {
			break
		}
		x := v_0_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		x := v_0_0.Args[1]
		y := v_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_1.Args[1]
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_1_0.AuxInt != 1 {
			break
		}
		x := v_0_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(isUint32PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = log2uint32(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0_0.AuxInt
		x := v_0.Args[1]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0_1.AuxInt
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		s := v_0.Args[0]
		if s.Op != OpAMD64ANDLconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		s := v_0.Args[0]
		if s.Op != OpAMD64ANDQconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQ_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQ_20(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETEQ)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQstore_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		x := v_1_0.Args[1]
		y := v_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_1.Args[1]
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_1_0.AuxInt != 1 {
			break
		}
		x := v_1_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		x := v_1_0.Args[1]
		y := v_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_1.Args[1]
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_1_0.AuxInt != 1 {
			break
		}
		x := v_1_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTLconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		mem := v.Args[2]
		if !(isUint32PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = log2uint32(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1_0.AuxInt
		x := v_1.Args[1]
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		x := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1_1.AuxInt
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64CMPLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		s := v_1.Args[0]
		if s.Op != OpAMD64ANDLconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64CMPQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		s := v_1.Args[0]
		if s.Op != OpAMD64ANDQconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQstore_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETEQstore_20(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETAEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETG_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETL)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETGE_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETLE)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETGEstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETLEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETGEstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETGEstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETGstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETLstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETGstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETGstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETL_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETG)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETLE_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETGE)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETLEstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETGEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETLEstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETLEstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SETLstore_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETGstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETLstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETLstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNE_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		x := v_0_0.Args[1]
		y := v_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_0_1.Args[1]
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_1_0.AuxInt != 1 {
			break
		}
		x := v_0_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_0.Args[1]
		v_0_0_0 := v_0_0.Args[0]
		if v_0_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_0_0.AuxInt != 1 {
			break
		}
		x := v_0_0.Args[1]
		y := v_0.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		y := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0_1.Args[1]
		v_0_1_0 := v_0_1.Args[0]
		if v_0_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_1_0.AuxInt != 1 {
			break
		}
		x := v_0_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(isUint32PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = log2uint32(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0_0.AuxInt
		x := v_0.Args[1]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		x := v_0.Args[0]
		v_0_1 := v_0.Args[1]
		if v_0_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0_1.AuxInt
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64CMPLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		s := v_0.Args[0]
		if s.Op != OpAMD64ANDLconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64CMPQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		s := v_0.Args[0]
		if s.Op != OpAMD64ANDQconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNE_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTQ {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNE_20(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z1 := v_0.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		z2 := v_0.Args[1]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64TESTL {
			break
		}
		_ = v_0.Args[1]
		z2 := v_0.Args[0]
		z1 := v_0.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64InvertFlags {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETNE)
		v.AddArg(x)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagEQ {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagLT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_ULT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64FlagGT_UGT {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 1
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNEstore_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		x := v_1_0.Args[1]
		y := v_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1_1.Args[1]
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_1_0.AuxInt != 1 {
			break
		}
		x := v_1_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_0.Args[1]
		v_1_0_0 := v_1_0.Args[0]
		if v_1_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_0_0.AuxInt != 1 {
			break
		}
		x := v_1_0.Args[1]
		y := v_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		y := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1_1.Args[1]
		v_1_1_0 := v_1_1.Args[0]
		if v_1_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_1_0.AuxInt != 1 {
			break
		}
		x := v_1_1.Args[1]
		mem := v.Args[2]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTLconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		mem := v.Args[2]
		if !(isUint32PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = log2uint32(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQconst {
			break
		}
		c := v_1.AuxInt
		x := v_1.Args[0]
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1_0.AuxInt
		x := v_1.Args[1]
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		x := v_1.Args[0]
		v_1_1 := v_1.Args[1]
		if v_1_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1_1.AuxInt
		mem := v.Args[2]
		if !(isUint64PowerOfTwo(c) && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = log2(c)
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64CMPLconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		s := v_1.Args[0]
		if s.Op != OpAMD64ANDLconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64CMPQconst {
			break
		}
		if v_1.AuxInt != 1 {
			break
		}
		s := v_1.Args[0]
		if s.Op != OpAMD64ANDQconst {
			break
		}
		if s.AuxInt != 1 {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64SETEQstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(s)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNEstore_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHLQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHLLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHRLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLQconst {
			break
		}
		if z1_0.AuxInt != 63 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		z1_0 := z1.Args[0]
		if z1_0.Op != OpAMD64SHLLconst {
			break
		}
		if z1_0.AuxInt != 31 {
			break
		}
		x := z1_0.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTQ {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRQconst {
			break
		}
		if z1.AuxInt != 63 {
			break
		}
		x := z1.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
		v0.AuxInt = 63
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SETNEstore_20(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z1 := v_1.Args[0]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		z2 := v_1.Args[1]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64TESTL {
			break
		}
		_ = v_1.Args[1]
		z2 := v_1.Args[0]
		z1 := v_1.Args[1]
		if z1.Op != OpAMD64SHRLconst {
			break
		}
		if z1.AuxInt != 31 {
			break
		}
		x := z1.Args[0]
		mem := v.Args[2]
		if !(z1 == z2 && !config.nacl) {
			break
		}
		v.reset(OpAMD64SETBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
		v0.AuxInt = 31
		v0.AddArg(x)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64InvertFlags {
			break
		}
		x := v_1.Args[0]
		mem := v.Args[2]
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v.AddArg(x)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_0.AuxInt
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_0.AuxInt
		sym2 := v_0.Aux
		base := v_0.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SETNEstore)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(base)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagEQ {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagLT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_ULT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		x := v.Args[1]
		if x.Op != OpAMD64FlagGT_UGT {
			break
		}
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(ptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
		v0.AuxInt = 1
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHLL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHLLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHLLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHLLconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = 0
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHLQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHLQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHLQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHLQconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = 0
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 < 8) {
			break
		}
		v.reset(OpAMD64SHRBconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 < 8) {
			break
		}
		v.reset(OpAMD64SHRBconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 >= 8) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 >= 8) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRBconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHRLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHRLconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 0) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&31 == 31) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRLconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRLconst)
		v.AuxInt = 31
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHRQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SHRQconst)
		v.AuxInt = c & 63
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGQ {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDQconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ADDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 0) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1.AuxInt
		y := v_1.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64NEGL {
			break
		}
		t := v_1.Type
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64ANDLconst {
			break
		}
		c := v_1_0.AuxInt
		y := v_1_0.Args[0]
		if !(c&63 == 63) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64NEGL, t)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRQconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		if v_0.AuxInt != 1 {
			break
		}
		x := v_0.Args[0]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTRQconst)
		v.AuxInt = 63
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRW_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 < 16) {
			break
		}
		v.reset(OpAMD64SHRWconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 < 16) {
			break
		}
		v.reset(OpAMD64SHRWconst)
		v.AuxInt = c & 31
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 >= 16) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(c&31 >= 16) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SHRWconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SUBL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64SUBLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64NEGL)
		v0 := b.NewValue0(v.Pos, OpAMD64SUBLconst, v.Type)
		v0.AuxInt = c
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64SUBLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SUBLconst_0(v *Value) bool {

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(int32(c) == 0) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = int64(int32(-c))
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpAMD64SUBLload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SUBLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SUBLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSSstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SUBQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64SUBQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64NEGQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SUBQconst, v.Type)
		v0.AuxInt = c
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64SUBQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SUBQconst_0(v *Value) bool {

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(c != -(1 << 31)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = -c
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = d - c
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SUBQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		if !(is32Bit(-c - d)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = -c - d
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SUBQload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SUBQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SUBQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSDstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64SUBQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SUBSD_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSDload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64SUBSDload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SUBSDload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SUBSDload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SUBSDload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVQstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64SUBSD)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64SUBSS_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVSSload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64SUBSSload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64SUBSSload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64SUBSSload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64SUBSSload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVLstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64SUBSS)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64TESTB_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64TESTBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64TESTBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVBload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		l2 := v.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPBconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l2 := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVBload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPBconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64TESTBconst_0(v *Value) bool {

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		if !(x.Op != OpAMD64MOVLconst) {
			break
		}
		v.reset(OpAMD64TESTB)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64TESTL_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64TESTLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64TESTLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		l2 := v.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l2 := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPLconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64TESTLconst_0(v *Value) bool {

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		if !(x.Op != OpAMD64MOVLconst) {
			break
		}
		v.reset(OpAMD64TESTL)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64TESTQ_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64TESTQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64TESTQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		l2 := v.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l2 := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64TESTQconst_0(v *Value) bool {

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		if !(x.Op != OpAMD64MOVQconst) {
			break
		}
		v.reset(OpAMD64TESTQ)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64TESTW_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64TESTWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64TESTWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVWload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		l2 := v.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPWconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l2 := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVWload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(l == l2 && l.Uses == 2 && validValAndOff(0, off) && clobber(l)) {
			break
		}
		b = l.Block
		v0 := b.NewValue0(v.Pos, OpAMD64CMPWconstload, psess.types.TypeFlags)
		v.reset(OpCopy)
		v.AddArg(v0)
		v0.AuxInt = makeValAndOff(0, off)
		v0.Aux = sym
		v0.AddArg(ptr)
		v0.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64TESTWconst_0(v *Value) bool {

	for {
		if v.AuxInt != -1 {
			break
		}
		x := v.Args[0]
		if !(x.Op != OpAMD64MOVLconst) {
			break
		}
		v.reset(OpAMD64TESTW)
		v.AddArg(x)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XADDLlock_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XADDLlock)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XADDQlock_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XADDQlock)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XCHGL_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XCHGL)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64XCHGL)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XCHGQ_0(v *Value) bool {

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XCHGQ)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		ptr := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB) {
			break
		}
		v.reset(OpAMD64XCHGQ)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64XORL_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLL {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_0_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTCL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLL {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVLconst {
			break
		}
		if v_1_0.AuxInt != 1 {
			break
		}
		y := v_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTCL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVLconst {
			break
		}
		c := v_1.AuxInt
		v.reset(OpAMD64XORLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		v.reset(OpAMD64XORLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRLconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 32-c) {
			break
		}
		v.reset(OpAMD64ROLLconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRWconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRWconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 16-c && c < 16 && t.Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64ROLWconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64XORL_10(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLLconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRBconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRBconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLLconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 8-c && c < 8 && t.Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64ROLBconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64XORLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVLload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64XORLload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XORLconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint32PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCLconst)
		v.AuxInt = log2uint32(c)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETNE {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETEQ)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETEQ {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETNE)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETL {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETGE)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETGE {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETL)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETLE {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETG)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETG {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETLE)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETB {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETAE)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETAE {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETB)
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETBE {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETA)
		v.AddArg(x)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XORLconst_10(v *Value) bool {

	for {
		if v.AuxInt != 1 {
			break
		}
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SETA {
			break
		}
		x := v_0.Args[0]
		v.reset(OpAMD64SETBE)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64XORLconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64XORLconst)
		v.AuxInt = c ^ d
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(int32(c) == 0) {
			break
		}
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVLconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = c ^ d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XORLload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XORLload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64XORLload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSSstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64XORL)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64XORQ_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQ {
			break
		}
		_ = v_0.Args[1]
		v_0_0 := v_0.Args[0]
		if v_0_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_0_0.AuxInt != 1 {
			break
		}
		y := v_0.Args[1]
		x := v.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTCQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQ {
			break
		}
		_ = v_1.Args[1]
		v_1_0 := v_1.Args[0]
		if v_1_0.Op != OpAMD64MOVQconst {
			break
		}
		if v_1_0.AuxInt != 1 {
			break
		}
		y := v_1.Args[1]
		if !(!config.nacl) {
			break
		}
		v.reset(OpAMD64BTCQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64MOVQconst {
			break
		}
		c := v_1.AuxInt
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64XORQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		c := v_0.AuxInt
		x := v.Args[1]
		if !(is32Bit(c)) {
			break
		}
		v.reset(OpAMD64XORQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHLQconst {
			break
		}
		c := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHRQconst {
			break
		}
		d := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64SHRQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64SHLQconst {
			break
		}
		c := v_1.AuxInt
		if x != v_1.Args[0] {
			break
		}
		if !(d == 64-c) {
			break
		}
		v.reset(OpAMD64ROLQconst)
		v.AuxInt = c
		v.AddArg(x)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		if x != v.Args[1] {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		l := v.Args[1]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64XORQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpAMD64XORQ_10(v *Value) bool {

	for {
		_ = v.Args[1]
		l := v.Args[0]
		if l.Op != OpAMD64MOVQload {
			break
		}
		off := l.AuxInt
		sym := l.Aux
		_ = l.Args[1]
		ptr := l.Args[0]
		mem := l.Args[1]
		x := v.Args[1]
		if !(psess.canMergeLoad(v, l, x) && clobber(l)) {
			break
		}
		v.reset(OpAMD64XORQload)
		v.AuxInt = off
		v.Aux = sym
		v.AddArg(x)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XORQconst_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		c := v.AuxInt
		x := v.Args[0]
		if !(isUint64PowerOfTwo(c) && uint64(c) >= 128 && !config.nacl) {
			break
		}
		v.reset(OpAMD64BTCQconst)
		v.AuxInt = log2(c)
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64XORQconst {
			break
		}
		d := v_0.AuxInt
		x := v_0.Args[0]
		v.reset(OpAMD64XORQconst)
		v.AuxInt = c ^ d
		v.AddArg(x)
		return true
	}

	for {
		if v.AuxInt != 0 {
			break
		}
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}

	for {
		c := v.AuxInt
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64MOVQconst {
			break
		}
		d := v_0.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = c ^ d
		return true
	}
	return false
}
func rewriteValueAMD64_OpAMD64XORQload_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off1 := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64ADDQconst {
			break
		}
		off2 := v_1.AuxInt
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1 + off2)) {
			break
		}
		v.reset(OpAMD64XORQload)
		v.AuxInt = off1 + off2
		v.Aux = sym
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off1 := v.AuxInt
		sym1 := v.Aux
		_ = v.Args[2]
		val := v.Args[0]
		v_1 := v.Args[1]
		if v_1.Op != OpAMD64LEAQ {
			break
		}
		off2 := v_1.AuxInt
		sym2 := v_1.Aux
		base := v_1.Args[0]
		mem := v.Args[2]
		if !(is32Bit(off1+off2) && canMergeSym(sym1, sym2)) {
			break
		}
		v.reset(OpAMD64XORQload)
		v.AuxInt = off1 + off2
		v.Aux = mergeSym(sym1, sym2)
		v.AddArg(val)
		v.AddArg(base)
		v.AddArg(mem)
		return true
	}

	for {
		off := v.AuxInt
		sym := v.Aux
		_ = v.Args[2]
		x := v.Args[0]
		ptr := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64MOVSDstore {
			break
		}
		if v_2.AuxInt != off {
			break
		}
		if v_2.Aux != sym {
			break
		}
		_ = v_2.Args[2]
		if ptr != v_2.Args[0] {
			break
		}
		y := v_2.Args[1]
		v.reset(OpAMD64XORQ)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAdd16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAdd32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAdd32F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDSS)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAdd64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAdd64F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDSD)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAdd8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ADDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAddPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64ADDQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64ADDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAddr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		sym := v.Aux
		base := v.Args[0]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64LEAQ)
		v.Aux = sym
		v.AddArg(base)
		return true
	}

	for {
		sym := v.Aux
		base := v.Args[0]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64LEAL)
		v.Aux = sym
		v.AddArg(base)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAnd16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ANDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAnd32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ANDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAnd64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ANDQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAnd8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ANDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpAndB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ANDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpAtomicAdd32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64AddTupleFirst32)
		v.AddArg(val)
		v0 := b.NewValue0(v.Pos, OpAMD64XADDLlock, types.NewTuple(typ.UInt32, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpAtomicAdd64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64AddTupleFirst64)
		v.AddArg(val)
		v0 := b.NewValue0(v.Pos, OpAMD64XADDQlock, types.NewTuple(typ.UInt64, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpAtomicAnd8_0(v *Value) bool {

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64ANDBlock)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicCompareAndSwap32_0(v *Value) bool {

	for {
		_ = v.Args[3]
		ptr := v.Args[0]
		old := v.Args[1]
		new_ := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64CMPXCHGLlock)
		v.AddArg(ptr)
		v.AddArg(old)
		v.AddArg(new_)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicCompareAndSwap64_0(v *Value) bool {

	for {
		_ = v.Args[3]
		ptr := v.Args[0]
		old := v.Args[1]
		new_ := v.Args[2]
		mem := v.Args[3]
		v.reset(OpAMD64CMPXCHGQlock)
		v.AddArg(ptr)
		v.AddArg(old)
		v.AddArg(new_)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicExchange32_0(v *Value) bool {

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64XCHGL)
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicExchange64_0(v *Value) bool {

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64XCHGQ)
		v.AddArg(val)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicLoad32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVLatomicload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicLoad64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVQatomicload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpAtomicLoadPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64MOVQatomicload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64MOVLatomicload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAtomicOr8_0(v *Value) bool {

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64ORBlock)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpAtomicStore32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64XCHGL, types.NewTuple(typ.UInt32, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpAtomicStore64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64XCHGQ, types.NewTuple(typ.UInt64, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpAtomicStorePtrNoWB_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64XCHGQ, types.NewTuple(typ.BytePtr, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64XCHGL, types.NewTuple(typ.BytePtr, psess.types.TypeMem))
		v0.AddArg(val)
		v0.AddArg(ptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpAvg64u_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64AVGQU)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpBitLen16_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSRL)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL1, typ.UInt32)
		v0.AuxInt = 1
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWQZX, typ.UInt32)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWQZX, typ.UInt32)
		v2.AddArg(x)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpBitLen32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64BSRQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v1 := b.NewValue0(v.Pos, OpAMD64LEAQ1, typ.UInt64)
		v1.AuxInt = 1
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLQZX, typ.UInt64)
		v2.AddArg(x)
		v1.AddArg(v2)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVLQZX, typ.UInt64)
		v3.AddArg(x)
		v1.AddArg(v3)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpBitLen64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		t := v.Type
		x := v.Args[0]
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = 1
		v0 := b.NewValue0(v.Pos, OpAMD64CMOVQEQ, t)
		v1 := b.NewValue0(v.Pos, OpSelect0, t)
		v2 := b.NewValue0(v.Pos, OpAMD64BSRQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v2.AddArg(x)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVQconst, t)
		v3.AuxInt = -1
		v0.AddArg(v3)
		v4 := b.NewValue0(v.Pos, OpSelect1, psess.types.TypeFlags)
		v5 := b.NewValue0(v.Pos, OpAMD64BSRQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v5.AddArg(x)
		v4.AddArg(v5)
		v0.AddArg(v4)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpBitLen8_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSRL)
		v0 := b.NewValue0(v.Pos, OpAMD64LEAL1, typ.UInt32)
		v0.AuxInt = 1
		v1 := b.NewValue0(v.Pos, OpAMD64MOVBQZX, typ.UInt32)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVBQZX, typ.UInt32)
		v2.AddArg(x)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpBswap32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSWAPL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpBswap64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSWAPQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCeil_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64ROUNDSD)
		v.AuxInt = 2
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpClosureCall_0(v *Value) bool {

	for {
		argwid := v.AuxInt
		_ = v.Args[2]
		entry := v.Args[0]
		closure := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64CALLclosure)
		v.AuxInt = argwid
		v.AddArg(entry)
		v.AddArg(closure)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpCom16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NOTL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCom32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NOTL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCom64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NOTQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCom8_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NOTL)
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpCondSelect_0(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQ {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQEQ)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQNE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETL {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQLT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETG {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQGT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETLE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQLE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQGE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETA {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQHI)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETB {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQCS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETAE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQCC)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETBE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQLS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpCondSelect_10(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQEQF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQNEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQGTF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is64BitInt(t) || isPtr(t)) {
			break
		}
		v.reset(OpAMD64CMOVQGEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQ {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLEQ)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLNE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETL {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLLT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETG {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLGT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETLE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLLE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLGE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpCondSelect_20(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETA {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLHI)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETB {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLCS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETAE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLCC)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETBE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLLS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLEQF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLNEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLGTF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLGEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQ {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWEQ)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWNE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpCondSelect_30(v *Value) bool {

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETL {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWLT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETG {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWGT)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETLE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWLE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWGE)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETA {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWHI)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETB {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWCS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETAE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWCC)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETBE {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWLS)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETEQF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWEQF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETNEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWNEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpCondSelect_40(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWGTF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		v_2 := v.Args[2]
		if v_2.Op != OpAMD64SETGEF {
			break
		}
		cond := v_2.Args[0]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWGEF)
		v.AddArg(y)
		v.AddArg(x)
		v.AddArg(cond)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 1) {
			break
		}
		v.reset(OpCondSelect)
		v.Type = t
		v.AddArg(x)
		v.AddArg(y)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQZX, typ.UInt64)
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 2) {
			break
		}
		v.reset(OpCondSelect)
		v.Type = t
		v.AddArg(x)
		v.AddArg(y)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWQZX, typ.UInt64)
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 4) {
			break
		}
		v.reset(OpCondSelect)
		v.Type = t
		v.AddArg(x)
		v.AddArg(y)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLQZX, typ.UInt64)
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 8 && (psess.is64BitInt(t) || isPtr(t))) {
			break
		}
		v.reset(OpAMD64CMOVQNE)
		v.AddArg(y)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 8 && psess.is32BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVLNE)
		v.AddArg(y)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[2]
		x := v.Args[0]
		y := v.Args[1]
		check := v.Args[2]
		if !(!check.Type.IsFlags(psess.types) && check.Type.Size(psess.types) == 8 && psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64CMOVWNE)
		v.AddArg(y)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v0.AuxInt = 0
		v0.AddArg(check)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpConst16_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConst32_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConst32F_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVSSconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConst64_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConst64F_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVSDconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConst8_0(v *Value) bool {

	for {
		val := v.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = val
		return true
	}
}
func rewriteValueAMD64_OpConstBool_0(v *Value) bool {

	for {
		b := v.AuxInt
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = b
		return true
	}
}
func rewriteValueAMD64_OpConstNil_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64MOVQconst)
		v.AuxInt = 0
		return true
	}

	for {
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64MOVLconst)
		v.AuxInt = 0
		return true
	}
	return false
}
func rewriteValueAMD64_OpCtz16_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSFL)
		v0 := b.NewValue0(v.Pos, OpAMD64BTSLconst, typ.UInt32)
		v0.AuxInt = 16
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpCtz16NonZero_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSFL)
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpCtz32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v1 := b.NewValue0(v.Pos, OpAMD64BTSQconst, typ.UInt64)
		v1.AuxInt = 32
		v1.AddArg(x)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpCtz32NonZero_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSFL)
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpCtz64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		t := v.Type
		x := v.Args[0]
		v.reset(OpAMD64CMOVQEQ)
		v0 := b.NewValue0(v.Pos, OpSelect0, t)
		v1 := b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v1.AddArg(x)
		v0.AddArg(v1)
		v.AddArg(v0)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQconst, t)
		v2.AuxInt = 64
		v.AddArg(v2)
		v3 := b.NewValue0(v.Pos, OpSelect1, psess.types.TypeFlags)
		v4 := b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v4.AddArg(x)
		v3.AddArg(v4)
		v.AddArg(v3)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpCtz64NonZero_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, psess.types.TypeFlags))
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpCtz8_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSFL)
		v0 := b.NewValue0(v.Pos, OpAMD64BTSLconst, typ.UInt32)
		v0.AuxInt = 8
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpCtz8NonZero_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64BSFL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt32Fto32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTTSS2SL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt32Fto64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTTSS2SQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt32Fto64F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSS2SD)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt32to32F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSL2SS)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt32to64F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSL2SD)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt64Fto32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTTSD2SL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt64Fto32F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSD2SS)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt64Fto64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTTSD2SQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt64to32F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSQ2SS)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpCvt64to64F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64CVTSQ2SD)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpDiv128u_0(v *Value) bool {

	for {
		_ = v.Args[2]
		xhi := v.Args[0]
		xlo := v.Args[1]
		y := v.Args[2]
		v.reset(OpAMD64DIVQU2)
		v.AddArg(xhi)
		v.AddArg(xlo)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpDiv16_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv16u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVL, types.NewTuple(typ.Int32, typ.Int32))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv32F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64DIVSS)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpDiv32u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVLU, types.NewTuple(typ.UInt32, typ.UInt32))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVQ, types.NewTuple(typ.Int64, typ.Int64))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv64F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64DIVSD)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpDiv64u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVQU, types.NewTuple(typ.UInt64, typ.UInt64))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv8_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16))
		v1 := b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16)
		v2.AddArg(y)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpDiv8u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect0)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16))
		v1 := b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16)
		v2.AddArg(y)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEq8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEqB_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpEqPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SETEQ)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpFloor_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64ROUNDSD)
		v.AuxInt = 1
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq16U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq32U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq64U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGeq8U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETAE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpGetCallerPC_0(v *Value) bool {

	for {
		v.reset(OpAMD64LoweredGetCallerPC)
		return true
	}
}
func rewriteValueAMD64_OpGetCallerSP_0(v *Value) bool {

	for {
		v.reset(OpAMD64LoweredGetCallerSP)
		return true
	}
}
func rewriteValueAMD64_OpGetClosurePtr_0(v *Value) bool {

	for {
		v.reset(OpAMD64LoweredGetClosurePtr)
		return true
	}
}
func rewriteValueAMD64_OpGetG_0(v *Value) bool {

	for {
		mem := v.Args[0]
		v.reset(OpAMD64LoweredGetG)
		v.AddArg(mem)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETG)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater16U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETA)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETG)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater32U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETA)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETG)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater64U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETA)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETG)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpGreater8U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETA)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpHmul32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64HMULL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpHmul32u_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64HMULLU)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpHmul64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64HMULQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpHmul64u_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64HMULQU)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpInt64Hi_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64SHRQconst)
		v.AuxInt = 32
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpInterCall_0(v *Value) bool {

	for {
		argwid := v.AuxInt
		_ = v.Args[1]
		entry := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64CALLinter)
		v.AuxInt = argwid
		v.AddArg(entry)
		v.AddArg(mem)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpIsInBounds_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		idx := v.Args[0]
		len := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(idx)
		v0.AddArg(len)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		idx := v.Args[0]
		len := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(idx)
		v0.AddArg(len)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpIsNonNil_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		p := v.Args[0]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64TESTQ, psess.types.TypeFlags)
		v0.AddArg(p)
		v0.AddArg(p)
		v.AddArg(v0)
		return true
	}

	for {
		p := v.Args[0]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64TESTL, psess.types.TypeFlags)
		v0.AddArg(p)
		v0.AddArg(p)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpIsSliceInBounds_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		idx := v.Args[0]
		len := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(idx)
		v0.AddArg(len)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		idx := v.Args[0]
		len := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(idx)
		v0.AddArg(len)
		v.AddArg(v0)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETLE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq16U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETLE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(y)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq32U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETLE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(y)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq64U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETLE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLeq8U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETBE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETL)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess16U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETL)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(y)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess32U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETL)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETGF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(y)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess64U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETL)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLess8U_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETB)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpLoad_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(psess.is64BitInt(t) || isPtr(t) && config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64MOVQload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(psess.is32BitInt(t) || isPtr(t) && config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64MOVLload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(psess.is16BitInt(t)) {
			break
		}
		v.reset(OpAMD64MOVWload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(t.IsBoolean() || psess.is8BitInt(t)) {
			break
		}
		v.reset(OpAMD64MOVBload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(psess.is32BitFloat(t)) {
			break
		}
		v.reset(OpAMD64MOVSSload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Type
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		if !(psess.is64BitFloat(t)) {
			break
		}
		v.reset(OpAMD64MOVSDload)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh16x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh16x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh16x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh16x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh32x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh32x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh32x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh32x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh64x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh64x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh64x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh64x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh8x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh8x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh8x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpLsh8x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHLL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHLL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpMod16_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod16u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod32_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVL, types.NewTuple(typ.Int32, typ.Int32))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod32u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVLU, types.NewTuple(typ.UInt32, typ.UInt32))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod64_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVQ, types.NewTuple(typ.Int64, typ.Int64))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod64u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVQU, types.NewTuple(typ.UInt64, typ.UInt64))
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod8_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16))
		v1 := b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16)
		v2.AddArg(y)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpMod8u_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpSelect1)
		v0 := b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16))
		v1 := b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16)
		v1.AddArg(x)
		v0.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16)
		v2.AddArg(y)
		v0.AddArg(v2)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpMove_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config
	typ := &b.Func.Config.Types
	_ = typ

	for {
		if v.AuxInt != 0 {
			break
		}
		_ = v.Args[2]
		mem := v.Args[2]
		v.reset(OpCopy)
		v.Type = mem.Type
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8)
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 2 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWstore)
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 4 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstore)
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 8 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVQstore)
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 16 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVOload, psess.types.TypeInt128)
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 16 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(!config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = 8
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v0.AuxInt = 8
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 32 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpMove)
		v.AuxInt = 16
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = 16
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = 16
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpMove, psess.types.TypeMem)
		v2.AuxInt = 16
		v2.AddArg(dst)
		v2.AddArg(src)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}

	for {
		if v.AuxInt != 48 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(config.useSSE) {
			break
		}
		v.reset(OpMove)
		v.AuxInt = 32
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = 16
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = 16
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpMove, psess.types.TypeMem)
		v2.AuxInt = 16
		v2.AddArg(dst)
		v2.AddArg(src)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}

	for {
		if v.AuxInt != 64 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(config.useSSE) {
			break
		}
		v.reset(OpMove)
		v.AuxInt = 32
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = 32
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = 32
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpMove, psess.types.TypeMem)
		v2.AuxInt = 32
		v2.AddArg(dst)
		v2.AddArg(src)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpMove_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config
	typ := &b.Func.Config.Types
	_ = typ

	for {
		if v.AuxInt != 3 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = 2
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8)
		v0.AuxInt = 2
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVWstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 5 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVBstore)
		v.AuxInt = 4
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8)
		v0.AuxInt = 4
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 6 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVWstore)
		v.AuxInt = 4
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16)
		v0.AuxInt = 4
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 7 {
			break
		}
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64MOVLstore)
		v.AuxInt = 3
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v0.AuxInt = 3
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVLstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(s > 8 && s < 16) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AuxInt = s - 8
		v.AddArg(dst)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v0.AuxInt = s - 8
		v0.AddArg(src)
		v0.AddArg(mem)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstore, psess.types.TypeMem)
		v1.AddArg(dst)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v2.AddArg(src)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(s > 16 && s%16 != 0 && s%16 <= 8) {
			break
		}
		v.reset(OpMove)
		v.AuxInt = s - s%16
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = s % 16
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = s % 16
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQstore, psess.types.TypeMem)
		v2.AddArg(dst)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v3.AddArg(src)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(s > 16 && s%16 != 0 && s%16 > 8 && config.useSSE) {
			break
		}
		v.reset(OpMove)
		v.AuxInt = s - s%16
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = s % 16
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = s % 16
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v2.AddArg(dst)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVOload, psess.types.TypeInt128)
		v3.AddArg(src)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(s > 16 && s%16 != 0 && s%16 > 8 && !config.useSSE) {
			break
		}
		v.reset(OpMove)
		v.AuxInt = s - s%16
		v0 := b.NewValue0(v.Pos, OpOffPtr, dst.Type)
		v0.AuxInt = s % 16
		v0.AddArg(dst)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpOffPtr, src.Type)
		v1.AuxInt = s % 16
		v1.AddArg(src)
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQstore, psess.types.TypeMem)
		v2.AuxInt = 8
		v2.AddArg(dst)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v3.AuxInt = 8
		v3.AddArg(src)
		v3.AddArg(mem)
		v2.AddArg(v3)
		v4 := b.NewValue0(v.Pos, OpAMD64MOVQstore, psess.types.TypeMem)
		v4.AddArg(dst)
		v5 := b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64)
		v5.AddArg(src)
		v5.AddArg(mem)
		v4.AddArg(v5)
		v4.AddArg(mem)
		v2.AddArg(v4)
		v.AddArg(v2)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !(s > 64 && s <= 16*64 && s%16 == 0 && !config.noDuffDevice) {
			break
		}
		v.reset(OpAMD64DUFFCOPY)
		v.AuxInt = 14 * (64 - s/16)
		v.AddArg(dst)
		v.AddArg(src)
		v.AddArg(mem)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[2]
		dst := v.Args[0]
		src := v.Args[1]
		mem := v.Args[2]
		if !((s > 16*64 || config.noDuffDevice) && s%8 == 0) {
			break
		}
		v.reset(OpAMD64REPMOVSQ)
		v.AddArg(dst)
		v.AddArg(src)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v0.AuxInt = s / 8
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpMul16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul32F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULSS)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul64F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULSD)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul64uhilo_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULQU2)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpMul8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64MULL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpNeg16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpNeg32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpNeg32F_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64PXOR)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVSSconst, typ.Float32)
		v0.AuxInt = f2i(math.Copysign(0, -1))
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpNeg64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NEGQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpNeg64F_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64PXOR)
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVSDconst, typ.Float64)
		v0.AuxInt = f2i(math.Copysign(0, -1))
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpNeg8_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64NEGL)
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPW, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq32F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISS, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq64F_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNEF)
		v0 := b.NewValue0(v.Pos, OpAMD64UCOMISD, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeq8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeqB_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPB, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpNeqPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPQ, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SETNE)
		v0 := b.NewValue0(v.Pos, OpAMD64CMPL, psess.types.TypeFlags)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpNilCheck_0(v *Value) bool {

	for {
		_ = v.Args[1]
		ptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64LoweredNilCheck)
		v.AddArg(ptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpNot_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64XORLconst)
		v.AuxInt = 1
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpOffPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config
	typ := &b.Func.Config.Types
	_ = typ

	for {
		off := v.AuxInt
		ptr := v.Args[0]
		if !(config.PtrSize == 8 && is32Bit(off)) {
			break
		}
		v.reset(OpAMD64ADDQconst)
		v.AuxInt = off
		v.AddArg(ptr)
		return true
	}

	for {
		off := v.AuxInt
		ptr := v.Args[0]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64ADDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v0.AuxInt = off
		v.AddArg(v0)
		v.AddArg(ptr)
		return true
	}

	for {
		off := v.AuxInt
		ptr := v.Args[0]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64ADDLconst)
		v.AuxInt = off
		v.AddArg(ptr)
		return true
	}
	return false
}
func rewriteValueAMD64_OpOr16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpOr32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpOr64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpOr8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpOrB_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64ORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpPopCount16_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64POPCNTL)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWQZX, typ.UInt32)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpPopCount32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64POPCNTL)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpPopCount64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64POPCNTQ)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpPopCount8_0(v *Value) bool {
	b := v.Block
	_ = b
	typ := &b.Func.Config.Types
	_ = typ

	for {
		x := v.Args[0]
		v.reset(OpAMD64POPCNTL)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVBQZX, typ.UInt32)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpRound32F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpRound64F_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpRoundToEven_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64ROUNDSD)
		v.AuxInt = 0
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16Ux16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRW, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 16
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16Ux32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRW, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 16
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16Ux64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRW, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 16
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16Ux8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRW, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 16
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v3.AuxInt = 16
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v3.AuxInt = 16
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v3.AuxInt = 16
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh16x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v3.AuxInt = 16
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARW)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32Ux16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32Ux32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32Ux64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32Ux8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRL, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 32
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v3.AuxInt = 32
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v3.AuxInt = 32
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v3.AuxInt = 32
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh32x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v3.AuxInt = 32
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64Ux16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64Ux32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64Ux64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64Ux8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDQ)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRQ, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 64
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v3.AuxInt = 64
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v3.AuxInt = 64
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v3.AuxInt = 64
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh64x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v3.AuxInt = 64
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8Ux16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRB, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v2.AuxInt = 8
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8Ux32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRB, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v2.AuxInt = 8
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8Ux64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRB, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v2.AuxInt = 8
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8Ux8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64ANDL)
		v0 := b.NewValue0(v.Pos, OpAMD64SHRB, t)
		v0.AddArg(x)
		v0.AddArg(y)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t)
		v2 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v2.AuxInt = 8
		v2.AddArg(y)
		v1.AddArg(v2)
		v.AddArg(v1)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SHRB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8x16_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPWconst, psess.types.TypeFlags)
		v3.AuxInt = 8
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8x32_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPLconst, psess.types.TypeFlags)
		v3.AuxInt = 8
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8x64_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORQ, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPQconst, psess.types.TypeFlags)
		v3.AuxInt = 8
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpRsh8x8_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(!shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.Type = t
		v.AddArg(x)
		v0 := b.NewValue0(v.Pos, OpAMD64ORL, y.Type)
		v0.AddArg(y)
		v1 := b.NewValue0(v.Pos, OpAMD64NOTL, y.Type)
		v2 := b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type)
		v3 := b.NewValue0(v.Pos, OpAMD64CMPBconst, psess.types.TypeFlags)
		v3.AuxInt = 8
		v3.AddArg(y)
		v2.AddArg(v3)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(shiftIsBounded(v)) {
			break
		}
		v.reset(OpAMD64SARB)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpSelect0_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64AddTupleFirst32 {
			break
		}
		_ = v_0.Args[1]
		val := v_0.Args[0]
		tuple := v_0.Args[1]
		v.reset(OpAMD64ADDL)
		v.AddArg(val)
		v0 := b.NewValue0(v.Pos, OpSelect0, t)
		v0.AddArg(tuple)
		v.AddArg(v0)
		return true
	}

	for {
		t := v.Type
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64AddTupleFirst64 {
			break
		}
		_ = v_0.Args[1]
		val := v_0.Args[0]
		tuple := v_0.Args[1]
		v.reset(OpAMD64ADDQ)
		v.AddArg(val)
		v0 := b.NewValue0(v.Pos, OpSelect0, t)
		v0.AddArg(tuple)
		v.AddArg(v0)
		return true
	}
	return false
}
func rewriteValueAMD64_OpSelect1_0(v *Value) bool {

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64AddTupleFirst32 {
			break
		}
		_ = v_0.Args[1]
		tuple := v_0.Args[1]
		v.reset(OpSelect1)
		v.AddArg(tuple)
		return true
	}

	for {
		v_0 := v.Args[0]
		if v_0.Op != OpAMD64AddTupleFirst64 {
			break
		}
		_ = v_0.Args[1]
		tuple := v_0.Args[1]
		v.reset(OpSelect1)
		v.AddArg(tuple)
		return true
	}
	return false
}
func rewriteValueAMD64_OpSignExt16to32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVWQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSignExt16to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVWQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSignExt32to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVLQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSignExt8to16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSignExt8to32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSignExt8to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQSX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpSlicemask_0(v *Value) bool {
	b := v.Block
	_ = b

	for {
		t := v.Type
		x := v.Args[0]
		v.reset(OpAMD64SARQconst)
		v.AuxInt = 63
		v0 := b.NewValue0(v.Pos, OpAMD64NEGQ, t)
		v0.AddArg(x)
		v.AddArg(v0)
		return true
	}
}
func rewriteValueAMD64_OpSqrt_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64SQRTSD)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpStaticCall_0(v *Value) bool {

	for {
		argwid := v.AuxInt
		target := v.Aux
		mem := v.Args[0]
		v.reset(OpAMD64CALLstatic)
		v.AuxInt = argwid
		v.Aux = target
		v.AddArg(mem)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpStore_0(v *Value) bool {

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 8 && psess.is64BitFloat(val.Type)) {
			break
		}
		v.reset(OpAMD64MOVSDstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 4 && psess.is32BitFloat(val.Type)) {
			break
		}
		v.reset(OpAMD64MOVSSstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 8) {
			break
		}
		v.reset(OpAMD64MOVQstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 4) {
			break
		}
		v.reset(OpAMD64MOVLstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 2) {
			break
		}
		v.reset(OpAMD64MOVWstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}

	for {
		t := v.Aux
		_ = v.Args[2]
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		if !(t.(*types.Type).Size(psess.types) == 1) {
			break
		}
		v.reset(OpAMD64MOVBstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpSub16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSub32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSub32F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBSS)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSub64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSub64F_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBSD)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSub8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpSubPtr_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 8) {
			break
		}
		v.reset(OpAMD64SUBQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		if !(config.PtrSize == 4) {
			break
		}
		v.reset(OpAMD64SUBL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
	return false
}
func rewriteValueAMD64_OpTrunc_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64ROUNDSD)
		v.AuxInt = 3
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc16to8_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc32to16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc32to8_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc64to16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc64to32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpTrunc64to8_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpCopy)
		v.Type = x.Type
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpWB_0(v *Value) bool {

	for {
		fn := v.Aux
		_ = v.Args[2]
		destptr := v.Args[0]
		srcptr := v.Args[1]
		mem := v.Args[2]
		v.reset(OpAMD64LoweredWB)
		v.Aux = fn
		v.AddArg(destptr)
		v.AddArg(srcptr)
		v.AddArg(mem)
		return true
	}
}
func rewriteValueAMD64_OpXor16_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64XORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpXor32_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64XORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpXor64_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64XORQ)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValueAMD64_OpXor8_0(v *Value) bool {

	for {
		_ = v.Args[1]
		x := v.Args[0]
		y := v.Args[1]
		v.reset(OpAMD64XORL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func (psess *PackageSession) rewriteValueAMD64_OpZero_0(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 0 {
			break
		}
		_ = v.Args[1]
		mem := v.Args[1]
		v.reset(OpCopy)
		v.Type = mem.Type
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 1 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = 0
		v.AddArg(destptr)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 2 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = 0
		v.AddArg(destptr)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 4 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = 0
		v.AddArg(destptr)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 8 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = 0
		v.AddArg(destptr)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 3 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = makeValAndOff(0, 2)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVWstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 5 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVBstoreconst)
		v.AuxInt = makeValAndOff(0, 4)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 6 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVWstoreconst)
		v.AuxInt = makeValAndOff(0, 4)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 7 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		v.reset(OpAMD64MOVLstoreconst)
		v.AuxInt = makeValAndOff(0, 3)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(s%8 != 0 && s > 8 && !config.useSSE) {
			break
		}
		v.reset(OpZero)
		v.AuxInt = s - s%8
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = s % 8
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v1.AuxInt = 0
		v1.AddArg(destptr)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpZero_10(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config

	for {
		if v.AuxInt != 16 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(!config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = makeValAndOff(0, 8)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 24 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(!config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = makeValAndOff(0, 16)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v0.AuxInt = makeValAndOff(0, 8)
		v0.AddArg(destptr)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v1.AuxInt = 0
		v1.AddArg(destptr)
		v1.AddArg(mem)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		if v.AuxInt != 32 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(!config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = makeValAndOff(0, 24)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v0.AuxInt = makeValAndOff(0, 16)
		v0.AddArg(destptr)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v1.AuxInt = makeValAndOff(0, 8)
		v1.AddArg(destptr)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v2.AuxInt = 0
		v2.AddArg(destptr)
		v2.AddArg(mem)
		v1.AddArg(v2)
		v0.AddArg(v1)
		v.AddArg(v0)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(s > 8 && s < 16 && config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVQstoreconst)
		v.AuxInt = makeValAndOff(0, s-8)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v0.AuxInt = 0
		v0.AddArg(destptr)
		v0.AddArg(mem)
		v.AddArg(v0)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(s%16 != 0 && s > 16 && s%16 > 8 && config.useSSE) {
			break
		}
		v.reset(OpZero)
		v.AuxInt = s - s%16
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = s % 16
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v1.AddArg(destptr)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v2.AuxInt = 0
		v1.AddArg(v2)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(s%16 != 0 && s > 16 && s%16 <= 8 && config.useSSE) {
			break
		}
		v.reset(OpZero)
		v.AuxInt = s - s%16
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = s % 16
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, psess.types.TypeMem)
		v1.AuxInt = 0
		v1.AddArg(destptr)
		v1.AddArg(mem)
		v.AddArg(v1)
		return true
	}

	for {
		if v.AuxInt != 16 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		if v.AuxInt != 32 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = 16
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v1.AuxInt = 0
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v2.AddArg(destptr)
		v3 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v3.AuxInt = 0
		v2.AddArg(v3)
		v2.AddArg(mem)
		v.AddArg(v2)
		return true
	}

	for {
		if v.AuxInt != 48 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = 32
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v1.AuxInt = 0
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v3 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v3.AuxInt = 16
		v3.AddArg(destptr)
		v2.AddArg(v3)
		v4 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v4.AuxInt = 0
		v2.AddArg(v4)
		v5 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v5.AddArg(destptr)
		v6 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v6.AuxInt = 0
		v5.AddArg(v6)
		v5.AddArg(mem)
		v2.AddArg(v5)
		v.AddArg(v2)
		return true
	}

	for {
		if v.AuxInt != 64 {
			break
		}
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(config.useSSE) {
			break
		}
		v.reset(OpAMD64MOVOstore)
		v0 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v0.AuxInt = 48
		v0.AddArg(destptr)
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v1.AuxInt = 0
		v.AddArg(v1)
		v2 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v3 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v3.AuxInt = 32
		v3.AddArg(destptr)
		v2.AddArg(v3)
		v4 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v4.AuxInt = 0
		v2.AddArg(v4)
		v5 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v6 := b.NewValue0(v.Pos, OpOffPtr, destptr.Type)
		v6.AuxInt = 16
		v6.AddArg(destptr)
		v5.AddArg(v6)
		v7 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v7.AuxInt = 0
		v5.AddArg(v7)
		v8 := b.NewValue0(v.Pos, OpAMD64MOVOstore, psess.types.TypeMem)
		v8.AddArg(destptr)
		v9 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v9.AuxInt = 0
		v8.AddArg(v9)
		v8.AddArg(mem)
		v5.AddArg(v8)
		v2.AddArg(v5)
		v.AddArg(v2)
		return true
	}
	return false
}
func (psess *PackageSession) rewriteValueAMD64_OpZero_20(v *Value) bool {
	b := v.Block
	_ = b
	config := b.Func.Config
	_ = config
	typ := &b.Func.Config.Types
	_ = typ

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !(s > 64 && s <= 1024 && s%16 == 0 && !config.noDuffDevice) {
			break
		}
		v.reset(OpAMD64DUFFZERO)
		v.AuxInt = s
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVOconst, psess.types.TypeInt128)
		v0.AuxInt = 0
		v.AddArg(v0)
		v.AddArg(mem)
		return true
	}

	for {
		s := v.AuxInt
		_ = v.Args[1]
		destptr := v.Args[0]
		mem := v.Args[1]
		if !((s > 1024 || (config.noDuffDevice && s > 64 || !config.useSSE && s > 32)) && s%8 == 0) {
			break
		}
		v.reset(OpAMD64REPSTOSQ)
		v.AddArg(destptr)
		v0 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v0.AuxInt = s / 8
		v.AddArg(v0)
		v1 := b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64)
		v1.AuxInt = 0
		v.AddArg(v1)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteValueAMD64_OpZeroExt16to32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpZeroExt16to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVWQZX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpZeroExt32to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVLQZX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpZeroExt8to16_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpZeroExt8to32_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
}
func rewriteValueAMD64_OpZeroExt8to64_0(v *Value) bool {

	for {
		x := v.Args[0]
		v.reset(OpAMD64MOVBQZX)
		v.AddArg(x)
		return true
	}
}
func (psess *PackageSession) rewriteBlockAMD64(b *Block) bool {
	config := b.Func.Config
	_ = config
	fe := b.Func.fe
	_ = fe
	typ := &config.Types
	_ = typ
	switch b.Kind {
	case BlockAMD64EQ:

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SHLL {
				break
			}
			_ = v_0.Args[1]
			v_0_0 := v_0.Args[0]
			if v_0_0.Op != OpAMD64MOVLconst {
				break
			}
			if v_0_0.AuxInt != 1 {
				break
			}
			x := v_0.Args[1]
			y := v.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			y := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SHLL {
				break
			}
			_ = v_1.Args[1]
			v_1_0 := v_1.Args[0]
			if v_1_0.Op != OpAMD64MOVLconst {
				break
			}
			if v_1_0.AuxInt != 1 {
				break
			}
			x := v_1.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SHLQ {
				break
			}
			_ = v_0.Args[1]
			v_0_0 := v_0.Args[0]
			if v_0_0.Op != OpAMD64MOVQconst {
				break
			}
			if v_0_0.AuxInt != 1 {
				break
			}
			x := v_0.Args[1]
			y := v.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			y := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SHLQ {
				break
			}
			_ = v_1.Args[1]
			v_1_0 := v_1.Args[0]
			if v_1_0.Op != OpAMD64MOVQconst {
				break
			}
			if v_1_0.AuxInt != 1 {
				break
			}
			x := v_1.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTLconst {
				break
			}
			c := v.AuxInt
			x := v.Args[0]
			if !(isUint32PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = log2uint32(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQconst {
				break
			}
			c := v.AuxInt
			x := v.Args[0]
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64MOVQconst {
				break
			}
			c := v_0.AuxInt
			x := v.Args[1]
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			x := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64MOVQconst {
				break
			}
			c := v_1.AuxInt
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHLQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHLQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHLLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHLLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLLconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLLconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			x := z1.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			x := z1.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			x := z1.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			x := z1.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64UGE
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64EQ
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}
	case BlockAMD64GE:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64LE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}
	case BlockAMD64GT:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64LT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}
	case BlockIf:

		for {
			v := b.Control
			if v.Op != OpAMD64SETL {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64LT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETLE {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64LE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETG {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64GT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETGE {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64GE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETEQ {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64EQ
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETNE {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64NE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETB {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64ULT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETBE {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64ULE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETA {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETAE {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETGF {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETGEF {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETEQF {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64EQF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64SETNEF {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64NEF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			_ = v
			cond := b.Control
			b.Kind = BlockAMD64NE
			v0 := b.NewValue0(v.Pos, OpAMD64TESTB, psess.types.TypeFlags)
			v0.AddArg(cond)
			v0.AddArg(cond)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}
	case BlockAMD64LE:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64GE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}
	case BlockAMD64LT:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64GT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}
	case BlockAMD64NE:

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETL {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETL {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64LT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETL {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETL {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64LT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETLE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETLE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64LE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETLE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETLE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64LE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETG {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETG {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64GT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETG {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETG {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64GT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64GE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64GE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETEQ {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETEQ {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64EQ
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETEQ {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETEQ {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64EQ
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETNE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETNE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64NE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETNE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETNE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64NE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETB {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETB {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64ULT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETB {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETB {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64ULT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETBE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETBE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64ULE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETBE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETBE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64ULE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETA {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETA {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETA {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETA {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETAE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETAE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETAE {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETAE {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SHLL {
				break
			}
			_ = v_0.Args[1]
			v_0_0 := v_0.Args[0]
			if v_0_0.Op != OpAMD64MOVLconst {
				break
			}
			if v_0_0.AuxInt != 1 {
				break
			}
			x := v_0.Args[1]
			y := v.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			y := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SHLL {
				break
			}
			_ = v_1.Args[1]
			v_1_0 := v_1.Args[0]
			if v_1_0.Op != OpAMD64MOVLconst {
				break
			}
			if v_1_0.AuxInt != 1 {
				break
			}
			x := v_1.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTL, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SHLQ {
				break
			}
			_ = v_0.Args[1]
			v_0_0 := v_0.Args[0]
			if v_0_0.Op != OpAMD64MOVQconst {
				break
			}
			if v_0_0.AuxInt != 1 {
				break
			}
			x := v_0.Args[1]
			y := v.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			y := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SHLQ {
				break
			}
			_ = v_1.Args[1]
			v_1_0 := v_1.Args[0]
			if v_1_0.Op != OpAMD64MOVQconst {
				break
			}
			if v_1_0.AuxInt != 1 {
				break
			}
			x := v_1.Args[1]
			if !(!config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, psess.types.TypeFlags)
			v0.AddArg(x)
			v0.AddArg(y)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTLconst {
				break
			}
			c := v.AuxInt
			x := v.Args[0]
			if !(isUint32PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = log2uint32(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQconst {
				break
			}
			c := v.AuxInt
			x := v.Args[0]
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64MOVQconst {
				break
			}
			c := v_0.AuxInt
			x := v.Args[1]
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			x := v.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64MOVQconst {
				break
			}
			c := v_1.AuxInt
			if !(isUint64PowerOfTwo(c) && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = log2(c)
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHLQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHLQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHLLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHLLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHRQconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLQconst {
				break
			}
			if z1_0.AuxInt != 63 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLLconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			z1_0 := z1.Args[0]
			if z1_0.Op != OpAMD64SHLLconst {
				break
			}
			if z1_0.AuxInt != 31 {
				break
			}
			x := z1_0.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 0
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			x := z1.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTQ {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRQconst {
				break
			}
			if z1.AuxInt != 63 {
				break
			}
			x := z1.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, psess.types.TypeFlags)
			v0.AuxInt = 63
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z1 := v.Args[0]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			x := z1.Args[0]
			z2 := v.Args[1]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTL {
				break
			}
			_ = v.Args[1]
			z2 := v.Args[0]
			z1 := v.Args[1]
			if z1.Op != OpAMD64SHRLconst {
				break
			}
			if z1.AuxInt != 31 {
				break
			}
			x := z1.Args[0]
			if !(z1 == z2 && !config.nacl) {
				break
			}
			b.Kind = BlockAMD64ULT
			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, psess.types.TypeFlags)
			v0.AuxInt = 31
			v0.AddArg(x)
			b.SetControl(v0)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGEF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGEF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETGEF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETGEF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETEQF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETEQF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64EQF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETEQF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETEQF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64EQF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETNEF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETNEF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64NEF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64TESTB {
				break
			}
			_ = v.Args[1]
			v_0 := v.Args[0]
			if v_0.Op != OpAMD64SETNEF {
				break
			}
			cmp := v_0.Args[0]
			v_1 := v.Args[1]
			if v_1.Op != OpAMD64SETNEF {
				break
			}
			if cmp != v_1.Args[0] {
				break
			}
			b.Kind = BlockAMD64NEF
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64NE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}
	case BlockAMD64UGE:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64ULE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}
	case BlockAMD64UGT:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64ULT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}
	case BlockAMD64ULE:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGE
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}
	case BlockAMD64ULT:

		for {
			v := b.Control
			if v.Op != OpAMD64InvertFlags {
				break
			}
			cmp := v.Args[0]
			b.Kind = BlockAMD64UGT
			b.SetControl(cmp)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagEQ {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagLT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_ULT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			return true
		}

		for {
			v := b.Control
			if v.Op != OpAMD64FlagGT_UGT {
				break
			}
			b.Kind = BlockFirst
			b.SetControl(nil)
			b.Aux = nil
			b.swapSuccessors()
			return true
		}
	}
	return false
}
